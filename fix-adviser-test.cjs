const fs = require('fs');
const CR = String.fromCharCode(13);
const LF = String.fromCharCode(10);
const CRLF = CR + LF;

function getLineEnding(content) {
  return content.includes(CRLF) ? CRLF : LF;
}

console.log('=== Fixing AdviserAgreements.test.tsx ===');
const advTestPath = 'templates/AdviserAgreements.test.tsx';
let advTest = fs.readFileSync(advTestPath, 'utf8');
const LE = getLineEnding(advTest);

const newAdvTest = [
  "import React from 'react';",
  "import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';",
  "import { vi } from 'vitest';",
  "import { AdviserAgreements } from './AdviserAgreements';",
  "import * as AgreementService from '../src/agreements/service';",
  "import { AdviserAgreement } from '../types';",
  "",
  "// Mock the service module",
  "vi.mock('../src/agreements/service');",
  "",
  "// Mock notifications to prevent side effects",
  "vi.mock('../src/utils/notifications', () => ({",
  "    notify: { success: vi.fn(), error: vi.fn(), info: vi.fn(), warning: vi.fn() },",
  "}));",
  "",
  "// Mock useAutoSave hook",
  "vi.mock('../src/hooks/useAutoSave', () => ({",
  "    useAutoSave: () => ({ clearSaved: vi.fn() }),",
  "}));",
  "",
  "const mockAgreements: AdviserAgreement[] = [",
  "    {",
  "        id: 'AGMT_001',",
  "        type: 'adviser',",
  "        title: 'Advisor Agreement: Sarah',",
  "        party: { name: 'Sarah', avatarUrl: 'https://i.pravatar.cc/150?u=sarah', walletAddress: '0xSarahWallet' },",
  "        termOfEngagement: 2,",
  "        startDate: '2023-01-01',",
  "        status: 'Active',",
  "        details: { starterAllocation: 1000, coreTermAllocation: 5000, performanceMilestones: [], guidingPrinciples: '', vestedTokens: 1500, vestingSchedule: [] },",
  "    },",
  "    {",
  "        id: 'AGMT_002',",
  "        type: 'adviser',",
  "        title: 'Advisor Agreement: Mike',",
  "        party: { name: 'Mike', avatarUrl: 'https://i.pravatar.cc/150?u=mike', walletAddress: '0xMikeWallet' },",
  "        termOfEngagement: 1,",
  "        startDate: '2022-06-01',",
  "        status: 'Completed',",
  "        details: { starterAllocation: 500, coreTermAllocation: 2500, performanceMilestones: [], guidingPrinciples: '', vestedTokens: 3000, vestingSchedule: [] },",
  "    },",
  "];",
  "",
  "describe('AdviserAgreements', () => {",
  "    beforeEach(() => {",
  "        vi.mocked(AgreementService.getAgreements).mockResolvedValue([...mockAgreements]);",
  "        vi.mocked(AgreementService.signAgreement).mockImplementation(async (...args: any[]) => {",
  "            const id = args[0];",
  "            const agreement = mockAgreements.find(a => a.id === id);",
  "            return { ...agreement!, status: 'Completed' };",
  "        });",
  "        vi.mocked(AgreementService.getAgreementSignatures).mockResolvedValue({",
  "            signatures: [],",
  "            allSignatures: [],",
  "        });",
  "    });",
  "",
  "    afterEach(() => {",
  "        vi.clearAllMocks();",
  "    });",
  "",
  "    it('should render loading state and then display agreements', async () => {",
  "        render(<AdviserAgreements onNavigateToNegotiation={() => {}} />);",
  "",
  "        await waitFor(() => {",
  "            expect(screen.getByText('Advisor Agreement: Sarah')).toBeInTheDocument();",
  "            expect(screen.getByText('Advisor Agreement: Mike')).toBeInTheDocument();",
  "        });",
  "    });",
  "",
  "    it('should filter agreements by status', async () => {",
  "        render(<AdviserAgreements onNavigateToNegotiation={() => {}} />);",
  "        await waitFor(() => expect(screen.getByText('Advisor Agreement: Sarah')).toBeInTheDocument());",
  "",
  "        expect(screen.getByText('Advisor Agreement: Sarah')).toBeInTheDocument();",
  "        expect(screen.getByText('Advisor Agreement: Mike')).toBeInTheDocument();",
  "",
  "        fireEvent.click(screen.getByRole('button', { name: /active/i }));",
  "        expect(screen.getByText('Advisor Agreement: Sarah')).toBeInTheDocument();",
  "        expect(screen.queryByText('Advisor Agreement: Mike')).not.toBeInTheDocument();",
  "",
  "        fireEvent.click(screen.getByRole('button', { name: /completed/i }));",
  "        expect(screen.queryByText('Advisor Agreement: Sarah')).not.toBeInTheDocument();",
  "        expect(screen.getByText('Advisor Agreement: Mike')).toBeInTheDocument();",
  "    });",
  "",
  "    it('should allow a user to view and sign an agreement', async () => {",
  "        render(<AdviserAgreements onNavigateToNegotiation={() => {}} />);",
  "        await waitFor(() => expect(screen.getByText('Advisor Agreement: Sarah')).toBeInTheDocument());",
  "",
  "        const viewButtons = screen.getAllByText('View Details');",
  "        await act(async () => {",
  "            fireEvent.click(viewButtons[0]);",
  "        });",
  "",
  "        await waitFor(() => expect(screen.getByText('Sign Agreement')).toBeInTheDocument());",
  "        await act(async () => {",
  "            fireEvent.click(screen.getByText('Sign Agreement'));",
  "        });",
  "",
  "        // Verify signAgreement was called with the agreement ID as first argument",
  "        await waitFor(() => {",
  "            expect(AgreementService.signAgreement).toHaveBeenCalled();",
  "            const call = vi.mocked(AgreementService.signAgreement).mock.calls[0];",
  "            expect(call[0]).toBe('AGMT_001');",
  "        });",
  "    });",
  "});",
  "",
].join(LE);

fs.writeFileSync(advTestPath, newAdvTest);
console.log('WROTE: templates/AdviserAgreements.test.tsx');
console.log('Fixed: signAgreement assertion now checks first arg only');
