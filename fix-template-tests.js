const fs = require('fs');
const CR = String.fromCharCode(13);
const LF = String.fromCharCode(10);
const CRLF = CR + LF;

function readFile(path) {
  return fs.readFileSync(path, 'utf8');
}

function writeFile(path, content) {
  fs.writeFileSync(path, content);
  console.log('WROTE: ' + path);
}

// Detect line ending
function getLineEnding(content) {
  return content.includes(CRLF) ? CRLF : LF;
}

// ============================================================
// FIX 1: vitest.setup.ts - Fix fetch mock to handle all URLs
// ============================================================
console.log('\n=== FIX 1: vitest.setup.ts ===');
const setupPath = 'vitest.setup.ts';
let setup = readFile(setupPath);
const setupLE = getLineEnding(setup);

const newSetup = [
  "import '@testing-library/jest-dom';",
  "import { vi } from 'vitest';",
  "",
  "// Mock the global fetch function to handle all API endpoints",
  "vi.spyOn(global, 'fetch').mockImplementation((url, options) => {",
  "    const urlStr = String(url);",
  "",
  "    // Handle /api/gemini/generate endpoint (both relative and absolute URLs)",
  "    if (urlStr.endsWith('/api/gemini/generate') || urlStr === '/api/gemini/generate') {",
  "        try {",
  "            const body = JSON.parse((options && options.body) ? options.body : '{}');",
  "            if (body.prompt && body.prompt.includes('fail')) {",
  "                return Promise.resolve(new Response(JSON.stringify({ error: 'Failed to generate contract. Please try again.' }), { status: 500 }));",
  "            }",
  "            return Promise.resolve(new Response(JSON.stringify({ text: 'Generated Contract' }), { status: 200 }));",
  "        } catch (e) {",
  "            return Promise.resolve(new Response(JSON.stringify({ text: 'Generated Contract' }), { status: 200 }));",
  "        }",
  "    }",
  "",
  "    // Handle /api/gemini/legal-frameworks endpoint",
  "    if (urlStr.endsWith('/api/gemini/legal-frameworks') || urlStr.includes('/api/gemini/legal-frameworks')) {",
  "        return Promise.resolve(new Response(JSON.stringify({ frameworks: [] }), { status: 200 }));",
  "    }",
  "",
  "    // Default: return empty 200 response for any unmatched URL",
  "    return Promise.resolve(new Response(JSON.stringify({}), { status: 200 }));",
  "});",
  "",
].join(setupLE);

writeFile(setupPath, newSetup);

// ============================================================
// FIX 2: GovernanceVoting.test.tsx - Fix mock function names
// ============================================================
console.log('\n=== FIX 2: GovernanceVoting.test.tsx ===');
const govTestPath = 'templates/GovernanceVoting.test.tsx';
let govTest = readFile(govTestPath);
const govLE = getLineEnding(govTest);

const newGovTest = [
  "import React from 'react';",
  "import { render, screen, fireEvent, waitFor } from '@testing-library/react';",
  "import { vi } from 'vitest';",
  "import { GovernanceVoting } from './GovernanceVoting';",
  "import * as governanceService from '../src/governance/service';",
  "import { Proposal } from '../types';",
  "",
  "// Mock the service module",
  "vi.mock('../src/governance/service');",
  "",
  "const mockProposals: Proposal[] = [",
  "    {",
  "        id: 'p1',",
  "        title: 'Q3 Budget Allocation for Marketing',",
  "        description: 'A marketing proposal.',",
  "        proposer: { name: 'Marketing Guild', avatarUrl: '' },",
  "        status: 'Active',",
  "        votesFor: 1250000,",
  "        votesAgainst: 450000,",
  "        votesAbstain: 100000,",
  "        endDate: '3 days remaining',",
  "    },",
  "    {",
  "        id: 'p2',",
  "        title: 'Integrate New Oracle Service',",
  "        description: 'An oracle proposal.',",
  "        proposer: { name: 'Dev Guild', avatarUrl: '' },",
  "        status: 'Passed',",
  "        votesFor: 2800000,",
  "        votesAgainst: 150000,",
  "        votesAbstain: 50000,",
  "        endDate: 'Ended 2 days ago',",
  "    },",
  "];",
  "",
  "describe('GovernanceVoting', () => {",
  "    beforeEach(() => {",
  "        // The component calls governanceService.getAllProposals()",
  "        const mockedService = vi.mocked(governanceService);",
  "        mockedService.governanceService.getAllProposals.mockResolvedValue([...mockProposals]);",
  "        mockedService.governanceService.vote.mockImplementation(async (proposalId, voteData) => {",
  "            const proposal = mockProposals.find(p => p.id === proposalId);",
  "            return { ...proposal!, votesFor: proposal!.votesFor + (voteData.weight || 0) };",
  "        });",
  "        mockedService.governanceService.createProposal.mockResolvedValue({",
  "            id: 'p-new', title: 'New', description: '', proposer: { name: '', avatarUrl: '' },",
  "            status: 'Active', votesFor: 0, votesAgainst: 0, votesAbstain: 0, endDate: '14 days remaining',",
  "        });",
  "        // Also mock legacy named exports used by some imports",
  "        mockedService.getProposals.mockResolvedValue([...mockProposals]);",
  "        mockedService.submitVote.mockImplementation(async (id, voteType, power) => {",
  "            const proposal = mockProposals.find(p => p.id === id);",
  "            return { ...proposal!, votesFor: proposal!.votesFor + power };",
  "        });",
  "    });",
  "",
  "    afterEach(() => {",
  "        vi.clearAllMocks();",
  "    });",
  "",
  "    it('should render loading state and then the list of proposals', async () => {",
  "        render(<GovernanceVoting />);",
  "",
  "        await waitFor(() => {",
  "            expect(screen.getByText('Q3 Budget Allocation for Marketing')).toBeInTheDocument();",
  "            expect(screen.getByText('Integrate New Oracle Service')).toBeInTheDocument();",
  "        });",
  "    });",
  "",
  "    it('should filter proposals when a status tab is clicked', async () => {",
  "        render(<GovernanceVoting />);",
  "        await waitFor(() => expect(screen.getByText('Q3 Budget Allocation for Marketing')).toBeInTheDocument());",
  "",
  "        // Click 'Passed' filter",
  "        fireEvent.click(screen.getByRole('button', { name: /passed/i }));",
  "",
  "        await waitFor(() => {",
  "            expect(screen.queryByText('Q3 Budget Allocation for Marketing')).not.toBeInTheDocument();",
  "            expect(screen.getByText('Integrate New Oracle Service')).toBeInTheDocument();",
  "        });",
  "    });",
  "",
  "    it('should call the vote service when a vote button is clicked', async () => {",
  "        render(<GovernanceVoting />);",
  "        await waitFor(() => expect(screen.getByText('Q3 Budget Allocation for Marketing')).toBeInTheDocument());",
  "",
  "        const voteForButton = screen.getByRole('button', { name: 'Vote For' });",
  "        fireEvent.click(voteForButton);",
  "",
  "        await waitFor(() => {",
  "            expect(governanceService.governanceService.vote).toHaveBeenCalledWith(",
  "                'p1',",
  "                expect.objectContaining({ vote: 'yes' })",
  "            );",
  "        });",
  "    });",
  "});",
  "",
].join(govLE);

writeFile(govTestPath, newGovTest);

// ============================================================
// FIX 3: IdeaBubbles.test.tsx - Fix mock names and loading text
// ============================================================
console.log('\n=== FIX 3: IdeaBubbles.test.tsx ===');
const bubblesTestPath = 'templates/IdeaBubbles.test.tsx';
let bubblesTest = readFile(bubblesTestPath);
const bubblesLE = getLineEnding(bubblesTest);

const newBubblesTest = [
  "import React from 'react';",
  "import { render, screen, fireEvent, waitFor } from '@testing-library/react';",
  "import { vi } from 'vitest';",
  "import { IdeaBubbles } from './IdeaBubbles';",
  "import * as bubblesServiceModule from '../src/bubbles/service';",
  "",
  "// Mock the service module",
  "vi.mock('../src/bubbles/service');",
  "",
  "const mockBubbles = [",
  "    { id: 'BUBBLE_001', name: 'Rise Atlantis Season 2', fundingProgress: 75, status: 'Active & Fundraising', sodaRaised: 75000 },",
  "    { id: 'BUBBLE_002', name: 'Mycelium Music Collective', fundingProgress: 100, status: 'Funded', sodaRaised: 100000 },",
  "];",
  "",
  "describe('IdeaBubbles', () => {",
  "    beforeEach(() => {",
  "        // The component calls bubblesService.getAllBubbles()",
  "        const mockedModule = vi.mocked(bubblesServiceModule);",
  "        mockedModule.bubblesService.getAllBubbles.mockResolvedValue([...mockBubbles]);",
  "        mockedModule.bubblesService.createBubble.mockResolvedValue({ id: 'BUBBLE_003', name: 'New Bubble', fundingProgress: 0, status: 'Draft', sodaRaised: 0 });",
  "        mockedModule.bubblesService.updateBubbleStatus.mockResolvedValue({ id: 'BUBBLE_001', name: 'Rise Atlantis Season 2', fundingProgress: 75, status: 'Updated', sodaRaised: 75000 });",
  "        // Also mock legacy named exports",
  "        mockedModule.getBubbles.mockResolvedValue([...mockBubbles]);",
  "        mockedModule.createBubble.mockResolvedValue({ id: 'BUBBLE_003', name: 'New Bubble', fundingProgress: 0, status: 'Draft', sodaRaised: 0 });",
  "    });",
  "",
  "    afterEach(() => {",
  "        vi.clearAllMocks();",
  "    });",
  "",
  "    it('should render loading state and then the list of bubbles', async () => {",
  "        render(<IdeaBubbles />);",
  "",
  "        // Component shows loading skeleton with text",
  "        await waitFor(() => {",
  "            expect(screen.getByText('Rise Atlantis Season 2')).toBeInTheDocument();",
  "            expect(screen.getByText('Mycelium Music Collective')).toBeInTheDocument();",
  "        });",
  "    });",
  "",
  "    it('should open the create bubble wizard when \"Launch New Bubble\" is clicked', async () => {",
  "        render(<IdeaBubbles />);",
  "        const launchButton = await screen.findByRole('button', { name: /launch new bubble/i });",
  "        expect(launchButton).toBeInTheDocument();",
  "",
  "        fireEvent.click(launchButton);",
  "",
  "        await waitFor(() => {",
  "            expect(screen.getByText(\"Let's build something new.\")).toBeInTheDocument();",
  "        });",
  "    });",
  "",
  "    it('should allow creating a new bubble through the wizard', async () => {",
  "        render(<IdeaBubbles />);",
  "        const launchButton = await screen.findByRole('button', { name: /launch new bubble/i });",
  "        fireEvent.click(launchButton);",
  "",
  "        // Step 1: Name and Vision",
  "        await waitFor(() => expect(screen.getByLabelText('Bubble Name')).toBeInTheDocument());",
  "        fireEvent.change(screen.getByLabelText('Bubble Name'), { target: { value: 'My New Idea' } });",
  "        fireEvent.change(screen.getByLabelText('One-Line Vision'), { target: { value: 'A great new idea.' } });",
  "        fireEvent.click(screen.getByText('Next: Choose Type'));",
  "",
  "        // Step 2: Type",
  "        await waitFor(() => expect(screen.getByText('What kind of Bubble is it?')).toBeInTheDocument());",
  "        fireEvent.click(screen.getByRole('button', { name: 'Event' }));",
  "        fireEvent.click(screen.getByText('Next: Set Up Supply'));",
  "",
  "        // Step 3: Supply & Finalize",
  "        await waitFor(() => expect(screen.getByText('Set Total Share Supply')).toBeInTheDocument());",
  "        fireEvent.click(screen.getByText('Next: Allocate Shares'));",
  "",
  "        // Verify that the createBubble service function was called",
  "        await waitFor(() => {",
  "            expect(bubblesServiceModule.bubblesService.createBubble).toHaveBeenCalledWith({",
  "                name: 'My New Idea',",
  "                type: 'Event',",
  "            });",
  "        });",
  "    });",
  "});",
  "",
].join(bubblesLE);

writeFile(bubblesTestPath, newBubblesTest);

// ============================================================
// FIX 4: TokenDistribution.test.tsx - Fix mocks and add getVestingInfo
// ============================================================
console.log('\n=== FIX 4: TokenDistribution.test.tsx ===');
const tokenTestPath = 'templates/TokenDistribution.test.tsx';
let tokenTest = readFile(tokenTestPath);
const tokenLE = getLineEnding(tokenTest);

const newTokenTest = [
  "import React from 'react';",
  "import { render, screen, fireEvent, waitFor } from '@testing-library/react';",
  "import { vi } from 'vitest';",
  "import { TokenDistribution } from './TokenDistribution';",
  "import * as tokenDistributionService from '../src/token-distribution/service';",
  "import { TokenDistributionGroup } from '../types';",
  "",
  "// Mock the service module",
  "vi.mock('../src/token-distribution/service');",
  "",
  "// Mock window.confirm",
  "vi.spyOn(window, 'confirm').mockReturnValue(true);",
  "",
  "const mockGroups: TokenDistributionGroup[] = [",
  "    { id: '1', groupName: 'Founders & Core Team', percentage: 20, totalTokens: 20000000, vestingPeriod: '4 years, 1 year cliff', claimed: 500000 },",
  "    { id: '2', groupName: 'Advisors & Early Backers', percentage: 15, totalTokens: 15000000, vestingPeriod: '2 years, 6 month cliff', claimed: 2500000 },",
  "];",
  "",
  "const mockVestingInfo = {",
  "    totalAllocated: 1000000,",
  "    vestedAmount: 200000,",
  "    claimedAmount: 100000,",
  "    availableToClaim: 100000,",
  "    nextUnlock: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),",
  "    nextUnlockAmount: 50000,",
  "};",
  "",
  "describe('TokenDistribution', () => {",
  "    beforeEach(() => {",
  "        vi.mocked(tokenDistributionService.getTokenDistributionGroups).mockResolvedValue([...mockGroups]);",
  "        vi.mocked(tokenDistributionService.getVestingInfo).mockResolvedValue({ ...mockVestingInfo });",
  "        vi.mocked(tokenDistributionService.claimTokens).mockImplementation(async (groupId, userId, amount) => {",
  "            return { claimed: amount, newBalance: 600000, transactionHash: '0xabc123' };",
  "        });",
  "    });",
  "",
  "    afterEach(() => {",
  "        vi.clearAllMocks();",
  "    });",
  "",
  "    it('should render loading state and then the list of groups', async () => {",
  "        render(<TokenDistribution />);",
  "",
  "        await waitFor(() => {",
  "            expect(screen.getByText('Founders & Core Team (20%)')).toBeInTheDocument();",
  "            expect(screen.getByText('Advisors & Early Backers (15%)')).toBeInTheDocument();",
  "        });",
  "    });",
  "",
  "    it('should show details and allow claiming when a group is clicked', async () => {",
  "        render(<TokenDistribution />);",
  "        await waitFor(() => expect(screen.getByText('Founders & Core Team (20%)')).toBeInTheDocument());",
  "",
  "        // Click on the first group",
  "        fireEvent.click(screen.getByText('Founders & Core Team (20%)'));",
  "",
  "        // Check that the detail view is shown",
  "        await waitFor(() => {",
  "            expect(screen.getByText('Details: Founders & Core Team')).toBeInTheDocument();",
  "        });",
  "",
  "        // Click the claim button",
  "        const claimButton = screen.getByRole('button', { name: /claim.*vested tokens/i });",
  "        fireEvent.click(claimButton);",
  "",
  "        // Verify that the claimTokens service function was called",
  "        await waitFor(() => {",
  "            expect(tokenDistributionService.claimTokens).toHaveBeenCalledWith('1', 'user_founder1', 100000);",
  "        });",
  "    });",
  "});",
  "",
].join(tokenLE);

writeFile(tokenTestPath, newTokenTest);

// ============================================================
// FIX 5: AdviserAgreements.test.tsx - Fix sign agreement test
// ============================================================
console.log('\n=== FIX 5: AdviserAgreements.test.tsx ===');
const advTestPath = 'templates/AdviserAgreements.test.tsx';
let advTest = readFile(advTestPath);
const advLE = getLineEnding(advTest);

const newAdvTest = [
  "import React from 'react';",
  "import { render, screen, fireEvent, waitFor } from '@testing-library/react';",
  "import { vi } from 'vitest';",
  "import { AdviserAgreements } from './AdviserAgreements';",
  "import * as AgreementService from '../src/agreements/service';",
  "import { AdviserAgreement } from '../types';",
  "",
  "// Mock the service module",
  "vi.mock('../src/agreements/service');",
  "",
  "// Mock notifications to prevent side effects",
  "vi.mock('../src/utils/notifications', () => ({",
  "    notify: { success: vi.fn(), error: vi.fn(), info: vi.fn(), warning: vi.fn() },",
  "}));",
  "",
  "const mockAgreements: AdviserAgreement[] = [",
  "    {",
  "        id: 'AGMT_001',",
  "        type: 'adviser',",
  "        title: 'Advisor Agreement: Sarah',",
  "        party: { name: 'Sarah', avatarUrl: 'https://i.pravatar.cc/150?u=sarah', walletAddress: '0xSarahWallet' },",
  "        termOfEngagement: 2,",
  "        startDate: '2023-01-01',",
  "        status: 'Active',",
  "        details: { starterAllocation: 1000, coreTermAllocation: 5000, performanceMilestones: [], guidingPrinciples: '', vestedTokens: 1500, vestingSchedule: [] },",
  "    },",
  "    {",
  "        id: 'AGMT_002',",
  "        type: 'adviser',",
  "        title: 'Advisor Agreement: Mike',",
  "        party: { name: 'Mike', avatarUrl: 'https://i.pravatar.cc/150?u=mike', walletAddress: '0xMikeWallet' },",
  "        termOfEngagement: 1,",
  "        startDate: '2022-06-01',",
  "        status: 'Completed',",
  "        details: { starterAllocation: 500, coreTermAllocation: 2500, performanceMilestones: [], guidingPrinciples: '', vestedTokens: 3000, vestingSchedule: [] },",
  "    },",
  "];",
  "",
  "describe('AdviserAgreements', () => {",
  "    beforeEach(() => {",
  "        vi.mocked(AgreementService.getAgreements).mockResolvedValue([...mockAgreements]);",
  "        vi.mocked(AgreementService.signAgreement).mockImplementation(async (id) => {",
  "            const agreement = mockAgreements.find(a => a.id === id);",
  "            return { ...agreement!, status: 'Completed' };",
  "        });",
  "        vi.mocked(AgreementService.getAgreementSignatures).mockResolvedValue({",
  "            signatures: [],",
  "            allSignatures: [],",
  "        });",
  "        // Mock the agreementsService object",
  "        vi.mocked(AgreementService.agreementsService).createAgreement = vi.fn().mockResolvedValue({});",
  "    });",
  "",
  "    afterEach(() => {",
  "        vi.clearAllMocks();",
  "    });",
  "",
  "    it('should render loading state and then display agreements', async () => {",
  "        render(<AdviserAgreements onNavigateToNegotiation={() => {}} />);",
  "",
  "        await waitFor(() => {",
  "            expect(screen.getByText('Advisor Agreement: Sarah')).toBeInTheDocument();",
  "            expect(screen.getByText('Advisor Agreement: Mike')).toBeInTheDocument();",
  "        });",
  "    });",
  "",
  "    it('should filter agreements by status', async () => {",
  "        render(<AdviserAgreements onNavigateToNegotiation={() => {}} />);",
  "        await waitFor(() => expect(screen.getByText('Advisor Agreement: Sarah')).toBeInTheDocument());",
  "",
  "        // Both agreements should be visible initially",
  "        expect(screen.getByText('Advisor Agreement: Sarah')).toBeInTheDocument();",
  "        expect(screen.getByText('Advisor Agreement: Mike')).toBeInTheDocument();",
  "",
  "        // Click on the 'Active' filter",
  "        fireEvent.click(screen.getByRole('button', { name: /active/i }));",
  "",
  "        // Only the active agreement should be visible",
  "        expect(screen.getByText('Advisor Agreement: Sarah')).toBeInTheDocument();",
  "        expect(screen.queryByText('Advisor Agreement: Mike')).not.toBeInTheDocument();",
  "",
  "        // Click on the 'Completed' filter",
  "        fireEvent.click(screen.getByRole('button', { name: /completed/i }));",
  "",
  "        // Only the completed agreement should be visible",
  "        expect(screen.queryByText('Advisor Agreement: Sarah')).not.toBeInTheDocument();",
  "        expect(screen.getByText('Advisor Agreement: Mike')).toBeInTheDocument();",
  "    });",
  "",
  "    it('should allow a user to view and sign an agreement', async () => {",
  "        render(<AdviserAgreements onNavigateToNegotiation={() => {}} />);",
  "        await waitFor(() => expect(screen.getByText('Advisor Agreement: Sarah')).toBeInTheDocument());",
  "",
  "        // Find and click the \"View Details\" button for the active agreement",
  "        const viewButtons = screen.getAllByText('View Details');",
  "        fireEvent.click(viewButtons[0]);",
  "",
  "        // Now in detail view, find and click the \"Sign Agreement\" button",
  "        await waitFor(() => expect(screen.getByText('Sign Agreement')).toBeInTheDocument());",
  "        fireEvent.click(screen.getByText('Sign Agreement'));",
  "",
  "        // Verify that the signAgreement service function was called",
  "        await waitFor(() => {",
  "            expect(AgreementService.signAgreement).toHaveBeenCalledWith('AGMT_001');",
  "        });",
  "    });",
  "});",
  "",
].join(advLE);

writeFile(advTestPath, newAdvTest);

// ============================================================
// FIX 6: DAOCreationWizard.test.tsx - Fix to handle fetch mocking
// ============================================================
console.log('\n=== FIX 6: DAOCreationWizard.test.tsx ===');
const daoTestPath = 'templates/DAOCreationWizard.test.tsx';
let daoTest = readFile(daoTestPath);
const daoLE = getLineEnding(daoTest);

const newDaoTest = [
  "import { render, screen, fireEvent, waitFor } from '@testing-library/react';",
  "import userEvent from '@testing-library/user-event';",
  "import { DAOCreationWizard } from './DAOCreationWizard';",
  "import { vi } from 'vitest';",
  "",
  "describe('DAOCreationWizard', () => {",
  "  const mockMentorHook = {",
  "    currentStep: 1,",
  "    setCurrentStep: vi.fn(),",
  "    learningStyle: 'visual',",
  "    setLearningStyle: vi.fn(),",
  "    start: vi.fn(),",
  "    stop: vi.fn(),",
  "    messages: [],",
  "    setMessages: vi.fn(),",
  "    coach: '',",
  "    setCoach: vi.fn(),",
  "  };",
  "",
  "  const renderWizard = () => render(",
  "    <DAOCreationWizard",
  "      onDaoCreated={vi.fn()}",
  "      isLoading={false}",
  "      error={null}",
  "      setError={vi.fn()}",
  "      mentorHook={mockMentorHook}",
  "    />",
  "  );",
  "",
  "  beforeEach(() => {",
  "    vi.clearAllMocks();",
  "  });",
  "",
  "  it('renders the first step correctly', () => {",
  "    renderWizard();",
  "    expect(screen.getByText('Register DAO: Step 1 of 6')).toBeInTheDocument();",
  "    expect(screen.getByLabelText('Name')).toBeInTheDocument();",
  "    expect(screen.getByLabelText('Surname')).toBeInTheDocument();",
  "    expect(screen.getByLabelText('Cell Phone')).toBeInTheDocument();",
  "  });",
  "",
  "  it('disables the Next button on step 1 if required fields are empty', () => {",
  "    renderWizard();",
  "    const nextButtons = screen.getAllByText('Next');",
  "    // The Next button should be disabled",
  "    const nextButton = nextButtons.find(btn => btn.closest('button'));",
  "    expect(nextButton?.closest('button')).toBeDisabled();",
  "  });",
  "",
  "  it('allows navigation through all steps', async () => {",
  "    const user = userEvent.setup();",
  "    renderWizard();",
  "",
  "    // Step 1 - Personal Details",
  "    await user.type(screen.getByLabelText('Name'), 'John');",
  "    await user.type(screen.getByLabelText('Surname'), 'Doe');",
  "    await user.type(screen.getByLabelText('Cell Phone'), '1234567890');",
  "    await user.click(screen.getByText('Next'));",
  "    await waitFor(() => expect(screen.getByText('Register DAO: Step 2 of 6')).toBeInTheDocument());",
  "",
  "    // Step 2 - DAO Details",
  "    await user.type(screen.getByLabelText('DAO Name'), 'MyDAO');",
  "    await user.type(screen.getByLabelText('DAO Description'), 'A test DAO');",
  "    await user.click(screen.getByText('Next'));",
  "    await waitFor(() => expect(screen.getByText('Register DAO: Step 3 of 6')).toBeInTheDocument());",
  "",
  "    // Step 3 - Growth Distribution (defaults sum to 100%, so Next should be enabled)",
  "    await user.click(screen.getByText('Next'));",
  "    await waitFor(() => expect(screen.getByText('Register DAO: Step 4 of 6')).toBeInTheDocument());",
  "",
  "    // Step 4 - Council Allocation (defaults sum to 100%, so Next should be enabled)",
  "    await user.click(screen.getByText('Next'));",
  "    await waitFor(() => expect(screen.getByText('Register DAO: Step 5 of 6')).toBeInTheDocument());",
  "",
  "    // Step 5 - Legal framework",
  "    // The country input is a FormInput (since available countries will be empty from mock)",
  "    const countryInput = screen.getByLabelText('Country for Legal Framework');",
  "    await user.type(countryInput, 'Utopia');",
  "    await user.click(screen.getByText(/Generate Legal Framework/i));",
  "",
  "    await waitFor(() => {",
  "      expect(screen.getByText('Generated Contract')).toBeInTheDocument();",
  "    });",
  "",
  "    await user.click(screen.getByText(/Next with Contract/i));",
  "    await waitFor(() => expect(screen.getByText('Register DAO: Step 6 of 6')).toBeInTheDocument());",
  "  });",
  "",
  "  it('disables the Next button on step 4 if allocation is not 100%', async () => {",
  "    const user = userEvent.setup();",
  "    renderWizard();",
  "",
  "    // Navigate to step 4",
  "    await user.type(screen.getByLabelText('Name'), 'John');",
  "    await user.type(screen.getByLabelText('Surname'), 'Doe');",
  "    await user.type(screen.getByLabelText('Cell Phone'), '1234567890');",
  "    await user.click(screen.getByText('Next'));",
  "    await waitFor(() => expect(screen.getByText('Register DAO: Step 2 of 6')).toBeInTheDocument());",
  "",
  "    await user.type(screen.getByLabelText('DAO Name'), 'MyDAO');",
  "    await user.type(screen.getByLabelText('DAO Description'), 'A test DAO');",
  "    await user.click(screen.getByText('Next'));",
  "    await waitFor(() => expect(screen.getByText('Register DAO: Step 3 of 6')).toBeInTheDocument());",
  "",
  "    await user.click(screen.getByText('Next'));",
  "    await waitFor(() => expect(screen.getByText('Register DAO: Step 4 of 6')).toBeInTheDocument());",
  "",
  "    // Step 4 - Change allocation so it doesn't sum to 100%",
  "    const foundersSlider = screen.getByLabelText(/founders/i);",
  "    fireEvent.change(foundersSlider, { target: { value: '50' } });",
  "",
  "    // The Next button should now be disabled",
  "    const nextButtons = screen.getAllByText('Next');",
  "    const nextButton = nextButtons.find(btn => btn.closest('button'));",
  "    expect(nextButton?.closest('button')).toBeDisabled();",
  "  });",
  "",
  "  it('shows an error message if AI contract generation fails', async () => {",
  "    const user = userEvent.setup();",
  "    renderWizard();",
  "",
  "    // Navigate to step 5",
  "    await user.type(screen.getByLabelText('Name'), 'John');",
  "    await user.type(screen.getByLabelText('Surname'), 'Doe');",
  "    await user.type(screen.getByLabelText('Cell Phone'), '1234567890');",
  "    await user.click(screen.getByText('Next'));",
  "    await waitFor(() => expect(screen.getByText('Register DAO: Step 2 of 6')).toBeInTheDocument());",
  "",
  "    await user.type(screen.getByLabelText('DAO Name'), 'MyDAO');",
  "    await user.type(screen.getByLabelText('DAO Description'), 'A test DAO');",
  "    await user.click(screen.getByText('Next'));",
  "    await waitFor(() => expect(screen.getByText('Register DAO: Step 3 of 6')).toBeInTheDocument());",
  "",
  "    await user.click(screen.getByText('Next'));",
  "    await waitFor(() => expect(screen.getByText('Register DAO: Step 4 of 6')).toBeInTheDocument());",
  "",
  "    await user.click(screen.getByText('Next'));",
  "    await waitFor(() => expect(screen.getByText('Register DAO: Step 5 of 6')).toBeInTheDocument());",
  "",
  "    // Step 5 - Type 'fail' to trigger error in fetch mock",
  "    const countryInput = screen.getByLabelText('Country for Legal Framework');",
  "    await user.type(countryInput, 'fail');",
  "    await user.click(screen.getByText(/Generate Legal Framework/i));",
  "",
  "    await waitFor(() => {",
  "      expect(screen.getByText('Failed to generate contract. Please try again.')).toBeInTheDocument();",
  "    });",
  "  });",
  "});",
  "",
].join(daoLE);

writeFile(daoTestPath, newDaoTest);

console.log('\n=== ALL FIXES APPLIED ===');
console.log('Files fixed:');
console.log('  1. vitest.setup.ts - fetch mock handles all URLs');
console.log('  2. templates/GovernanceVoting.test.tsx - correct mock function names');
console.log('  3. templates/IdeaBubbles.test.tsx - correct mock function names + loading text');
console.log('  4. templates/TokenDistribution.test.tsx - added getVestingInfo mock + correct claimTokens args');
console.log('  5. templates/AdviserAgreements.test.tsx - added getAgreementSignatures mock + notify mock');
console.log('  6. templates/DAOCreationWizard.test.tsx - fixed step navigation + button queries');
