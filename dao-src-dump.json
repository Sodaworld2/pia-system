{
  "App.tsx": "import React, { useState, useEffect, lazy, Suspense } from 'react';\r\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\r\nimport { useAuth } from './src/hooks/useAuth';\r\nimport { SkipLink } from './src/components/SkipLink';\r\nimport { PageLoadingSkeleton } from './src/components/LoadingFallback';\r\n\r\n// Lazy load pages\r\nconst LoginPage = lazy(() => import('./src/pages/Login'));\r\nconst CouncilPage = lazy(() => import('./src/pages/CouncilPage'));\r\nconst AdminPage = lazy(() => import('./src/pages/Admin'));\r\nconst WizardTestPage = lazy(() => import('./src/pages/WizardTestPage'));\r\nconst SignAgreement = lazy(() => import('./src/pages/SignAgreement'));\r\n\r\n// Root redirect component - now goes to /council\r\nconst RootRedirect: React.FC<{ isAuthenticated: boolean; isMagicLinkProcessing: boolean }> = ({ isAuthenticated, isMagicLinkProcessing }) => {\r\n  if (isMagicLinkProcessing) {\r\n    return (\r\n      <div className=\"min-h-screen w-full flex items-center justify-center\">\r\n        <div className=\"text-center\">\r\n          <div className=\"animate-spin h-12 w-12 border-4 border-purple-500 border-t-transparent rounded-full mx-auto mb-4\"></div>\r\n          <p className=\"text-white text-lg\">Completing sign-in...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!isAuthenticated) {\r\n    return <Navigate to=\"/login\" replace />;\r\n  }\r\n  return <Navigate to=\"/council\" replace />;\r\n};\r\n\r\nconst App: React.FC = () => {\r\n  const [isMagicLinkProcessing, setIsMagicLinkProcessing] = useState(false);\r\n  const auth = useAuth();\r\n\r\n  // Handle magic link completion\r\n  useEffect(() => {\r\n    const completeMagicLinkAuth = async () => {\r\n      if (window.location.search.includes('apiKey=') || window.location.search.includes('oobCode=')) {\r\n        console.log('üîó Detected magic link callback...');\r\n        setIsMagicLinkProcessing(true);\r\n        try {\r\n          await auth.completeMagicLink();\r\n          console.log('‚úÖ Magic link authentication successful!');\r\n          window.history.replaceState({}, document.title, window.location.pathname);\r\n        } catch (error: any) {\r\n          console.error('‚ùå Failed to complete magic link sign-in:', error);\r\n          alert('Login link expired or invalid. Please request a new one.');\r\n          window.location.href = '/login';\r\n        } finally {\r\n          setIsMagicLinkProcessing(false);\r\n        }\r\n      }\r\n    };\r\n    completeMagicLinkAuth();\r\n  }, [auth]);\r\n\r\n  return (\r\n    <div className=\"min-h-screen w-full flex flex-col bg-gradient-to-br from-[#1c1642] to-[#0c0a1d]\">\r\n      <SkipLink targetId=\"main-content\" />\r\n      <BrowserRouter>\r\n        <main id=\"main-content\" className=\"flex-1 flex flex-col\">\r\n          <Suspense fallback={<PageLoadingSkeleton />}>\r\n            <Routes>\r\n              <Route path=\"/login\" element={<LoginPage />} />\r\n              <Route path=\"/council\" element={<CouncilPage />} />\r\n              <Route path=\"/admin\" element={<AdminPage />} />\r\n              <Route path=\"/test/wizards\" element={<WizardTestPage />} />\r\n              <Route path=\"/sign/:token\" element={<SignAgreement />} />\r\n              <Route path=\"/\" element={<RootRedirect isAuthenticated={auth.isAuthenticated} isMagicLinkProcessing={isMagicLinkProcessing} />} />\r\n              <Route path=\"*\" element={<Navigate to=\"/\" replace />} />\r\n            </Routes>\r\n          </Suspense>\r\n        </main>\r\n      </BrowserRouter>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n",
  "AppNew.tsx": "import React, { useState, useEffect } from 'react';\r\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\r\nimport { useAuth } from './src/hooks/useAuth';\r\nimport type { DAOData } from './types';\r\n\r\n// Import pages directly\r\nimport LoginPage from './src/pages/Login';\r\nimport CreateDAOPage from './src/pages/CreateDAO';\r\nimport DashboardWrapper from './src/pages/DashboardWrapper';\r\nimport DashboardOverview from './src/pages/DashboardOverview';\r\nimport BubblesPage from './src/pages/Bubbles';\r\nimport AgreementsPage from './src/pages/Agreements';\r\nimport GovernancePage from './src/pages/Governance';\r\nimport TokensPage from './src/pages/Tokens';\r\nimport MarketplacePage from './src/pages/Marketplace';\r\nimport AdminPage from './src/pages/AdminPage';\r\n\r\nconst API_URL = import.meta.env.VITE_API_URL || '';\r\n\r\n// Wrapper component to pass daoData to Dashboard routes\r\nconst DashboardWithData: React.FC<{ daoData: DAOData | null; onLogout: () => void }> = ({ daoData, onLogout }) => {\r\n  if (!daoData) {\r\n    return <Navigate to=\"/create-dao\" replace />;\r\n  }\r\n  return <DashboardWrapper daoData={daoData} onLogout={onLogout} />;\r\n};\r\n\r\n// Root redirect component\r\nconst RootRedirect: React.FC<{ isAuthenticated: boolean; daoData: DAOData | null }> = ({ isAuthenticated, daoData }) => {\r\n  if (!isAuthenticated) {\r\n    return <Navigate to=\"/login\" replace />;\r\n  }\r\n  return daoData ? <Navigate to=\"/dashboard\" replace /> : <Navigate to=\"/create-dao\" replace />;\r\n};\r\n\r\nconst App: React.FC = () => {\r\n  const [daoData, setDaoData] = useState<DAOData | null>(null);\r\n  const auth = useAuth();\r\n\r\n  // Check for existing DAO on mount\r\n  useEffect(() => {\r\n    const checkForExistingDao = async () => {\r\n      try {\r\n        const response = await fetch(`${API_URL}/api/dao`);\r\n        if (response.ok) {\r\n          const existingDao = await response.json();\r\n          if (existingDao) {\r\n            setDaoData(existingDao);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Could not fetch existing DAO\", error);\r\n      }\r\n    };\r\n\r\n    if (auth.isAuthenticated) {\r\n      checkForExistingDao();\r\n    }\r\n  }, [auth.isAuthenticated]);\r\n\r\n  // Handle magic link completion\r\n  useEffect(() => {\r\n    const completeMagicLinkAuth = async () => {\r\n      if (window.location.search.includes('apiKey=') || window.location.search.includes('oobCode=')) {\r\n        console.log('üîó Detected magic link callback, attempting to complete sign-in...');\r\n        try {\r\n          await auth.completeMagicLink();\r\n          console.log('‚úÖ Magic link authentication successful!');\r\n          window.history.replaceState({}, document.title, window.location.origin);\r\n        } catch (error: any) {\r\n          console.error('‚ùå Failed to complete magic link sign-in:', error);\r\n          const errorMessage = error?.message || error?.toString() || 'Unknown error';\r\n\r\n          if (errorMessage.includes('invalid-action-code')) {\r\n            alert('‚ö†Ô∏è This login link has expired or was already used.\\\\n\\\\nPlease close this tab and request a new login link.');\r\n          } else if (!errorMessage.includes('email-already-in-use')) {\r\n            alert('‚ùå Failed to complete login: ' + errorMessage + '\\\\n\\\\nPlease try requesting a new login link.');\r\n            setTimeout(() => {\r\n              window.location.href = window.location.origin;\r\n            }, 1000);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    completeMagicLinkAuth();\r\n  }, [auth]);\r\n\r\n  const handleLogout = () => {\r\n    auth.signOut();\r\n    setDaoData(null);\r\n  };\r\n\r\n  const handleDaoCreated = (newDao: DAOData) => {\r\n    setDaoData(newDao);\r\n  };\r\n\r\n  return (\r\n    <div className=\"min-h-screen w-full flex flex-col bg-gradient-to-br from-[#1c1642] to-[#0c0a1d]\">\r\n      <BrowserRouter>\r\n        <Routes>\r\n          <Route path=\"/login\" element={<LoginPage />} />\r\n          <Route path=\"/create-dao\" element={<CreateDAOPage onDaoCreated={handleDaoCreated} />} />\r\n          <Route path=\"/dashboard\" element={<DashboardWithData daoData={daoData} onLogout={handleLogout} />}>\r\n            <Route index element={<Navigate to=\"/dashboard/overview\" replace />} />\r\n            <Route path=\"overview\" element={<DashboardOverview />} />\r\n            <Route path=\"bubbles\" element={<BubblesPage />} />\r\n            <Route path=\"agreements\" element={<AgreementsPage />} />\r\n            <Route path=\"governance\" element={<GovernancePage />} />\r\n            <Route path=\"tokens\" element={<TokensPage />} />\r\n            <Route path=\"marketplace\" element={<MarketplacePage />} />\r\n          </Route>\r\n          <Route path=\"/admin\" element={<AdminPage />} />\r\n          <Route path=\"/\" element={<RootRedirect isAuthenticated={auth.isAuthenticated} daoData={daoData} />} />\r\n          <Route path=\"*\" element={<Navigate to=\"/\" replace />} />\r\n        </Routes>\r\n      </BrowserRouter>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n",
  "src/routes/index.tsx": "import { createBrowserRouter, RouterProvider, Navigate } from 'react-router-dom';\r\nimport { lazy, Suspense } from 'react';\r\nimport { PageLoadingSkeleton } from '../components/LoadingFallback';\r\n\r\n// Lazy load all page components for optimal code splitting\r\nconst LoginPage = lazy(() => import('../pages/Login'));\r\nconst CreateDAOPage = lazy(() => import('../pages/CreateDAO'));\r\nconst DashboardLayout = lazy(() => import('../layouts/DashboardLayout'));\r\nconst DashboardOverview = lazy(() => import('../pages/DashboardOverview'));\r\nconst BubblesPage = lazy(() => import('../pages/BubblesPage'));\r\nconst AgreementsPage = lazy(() => import('../pages/AgreementsPage'));\r\nconst GovernancePage = lazy(() => import('../pages/GovernancePage'));\r\nconst TokensPage = lazy(() => import('../pages/TokensPage'));\r\nconst MarketplacePage = lazy(() => import('../pages/MarketplacePage'));\r\nconst AdminPage = lazy(() => import('../pages/Admin'));\r\nconst FounderWizardTest = lazy(() => import('../pages/FounderWizardTest'));\r\nconst WizardTestPage = lazy(() => import('../pages/WizardTestPage'));\r\nconst CouncilPage = lazy(() => import('../pages/CouncilPage'));\r\nconst SignAgreement = lazy(() => import('../pages/SignAgreement'));\r\n\r\n/**\r\n * Application router configuration using React Router v6\r\n *\r\n * Features:\r\n * - Lazy loading for all routes to optimize bundle size\r\n * - Nested routes for dashboard sections\r\n * - Automatic redirects for root and unknown routes\r\n * - Suspense boundaries with loading skeletons\r\n */\r\nconst router = createBrowserRouter([\r\n  {\r\n    path: '/login',\r\n    element: (\r\n      <Suspense fallback={<PageLoadingSkeleton />}>\r\n        <LoginPage />\r\n      </Suspense>\r\n    ),\r\n  },\r\n  {\r\n    path: '/create-dao',\r\n    element: (\r\n      <Suspense fallback={<PageLoadingSkeleton />}>\r\n        <CreateDAOPage />\r\n      </Suspense>\r\n    ),\r\n  },\r\n  {\r\n    path: '/dashboard',\r\n    element: (\r\n      <Suspense fallback={<PageLoadingSkeleton />}>\r\n        <DashboardLayout />\r\n      </Suspense>\r\n    ),\r\n    children: [\r\n      {\r\n        index: true,\r\n        element: <Navigate to=\"/dashboard/overview\" replace />,\r\n      },\r\n      {\r\n        path: 'overview',\r\n        element: (\r\n          <Suspense fallback={<PageLoadingSkeleton />}>\r\n            <DashboardOverview />\r\n          </Suspense>\r\n        ),\r\n      },\r\n      {\r\n        path: 'bubbles',\r\n        element: (\r\n          <Suspense fallback={<PageLoadingSkeleton />}>\r\n            <BubblesPage />\r\n          </Suspense>\r\n        ),\r\n      },\r\n      {\r\n        path: 'bubbles/:id',\r\n        element: (\r\n          <Suspense fallback={<PageLoadingSkeleton />}>\r\n            <BubblesPage />\r\n          </Suspense>\r\n        ),\r\n      },\r\n      {\r\n        path: 'agreements',\r\n        element: (\r\n          <Suspense fallback={<PageLoadingSkeleton />}>\r\n            <AgreementsPage />\r\n          </Suspense>\r\n        ),\r\n      },\r\n      {\r\n        path: 'agreements/:id',\r\n        element: (\r\n          <Suspense fallback={<PageLoadingSkeleton />}>\r\n            <AgreementsPage />\r\n          </Suspense>\r\n        ),\r\n      },\r\n      {\r\n        path: 'governance',\r\n        element: (\r\n          <Suspense fallback={<PageLoadingSkeleton />}>\r\n            <GovernancePage />\r\n          </Suspense>\r\n        ),\r\n      },\r\n      {\r\n        path: 'tokens',\r\n        element: (\r\n          <Suspense fallback={<PageLoadingSkeleton />}>\r\n            <TokensPage />\r\n          </Suspense>\r\n        ),\r\n      },\r\n      {\r\n        path: 'marketplace',\r\n        element: (\r\n          <Suspense fallback={<PageLoadingSkeleton />}>\r\n            <MarketplacePage />\r\n          </Suspense>\r\n        ),\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    path: '/admin',\r\n    element: (\r\n      <Suspense fallback={<PageLoadingSkeleton />}>\r\n        <AdminPage />\r\n      </Suspense>\r\n    ),\r\n  },\r\n  {\r\n    path: '/test/founder-wizard',\r\n    element: (\r\n      <Suspense fallback={<PageLoadingSkeleton />}>\r\n        <FounderWizardTest />\r\n      </Suspense>\r\n    ),\r\n  },\r\n  {\r\n    path: '/test/wizards',\r\n    element: (\r\n      <Suspense fallback={<PageLoadingSkeleton />}>\r\n        <WizardTestPage />\r\n      </Suspense>\r\n    ),\r\n  },\r\n  {\r\n    path: '/council',\r\n    element: (\r\n      <Suspense fallback={<PageLoadingSkeleton />}>\r\n        <CouncilPage />\r\n      </Suspense>\r\n    ),\r\n  },\r\n  {\r\n    path: '/sign/:token',\r\n    element: (\r\n      <Suspense fallback={<PageLoadingSkeleton />}>\r\n        <SignAgreement />\r\n      </Suspense>\r\n    ),\r\n  },\r\n  {\r\n    path: '/',\r\n    element: <Navigate to=\"/login\" replace />,\r\n  },\r\n  {\r\n    path: '*',\r\n    element: <Navigate to=\"/login\" replace />,\r\n  },\r\n]);\r\n\r\n/**\r\n * AppRouter component that provides routing for the entire application\r\n *\r\n * Usage:\r\n * ```tsx\r\n * import { AppRouter } from './routes';\r\n *\r\n * function App() {\r\n *   return <AppRouter />;\r\n * }\r\n * ```\r\n */\r\nexport const AppRouter = () => {\r\n  return <RouterProvider router={router} />;\r\n};\r\n",
  "src/dao/service.ts": "/**\n * DAO Service - REST API Client\n * Replaces Firebase httpsCallable with direct REST fetch calls\n * Backend runs at localhost:5003 (proxied via Vite /api -> localhost:5003)\n */\n\nimport type {\n    DAOMember,\n    DAOMemberInput,\n    DAOMembersGrouped,\n    DAOMembersStats,\n    VestingStatus,\n    ClaimHistory,\n    Proposal,\n    ProposalStatus,\n    VoteType,\n    Vote,\n    MyVote,\n    TreasuryTransaction,\n    TreasuryStats,\n    TreasuryStatus,\n    Milestone,\n    MilestoneWithMember,\n    MilestoneStatus,\n    MilestoneStats,\n} from './types';\n\nconst API_URL = import.meta.env.VITE_API_URL || '';\n\nasync function apiGet<T>(path: string): Promise<T> {\n  const response = await fetch(`${API_URL}${path}`);\n  if (!response.ok) throw new Error(`API error: ${response.status} ${response.statusText}`);\n  const json = await response.json();\n  return json;\n}\n\nasync function apiPost<T>(path: string, data?: any): Promise<T> {\n  const response = await fetch(`${API_URL}${path}`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: data ? JSON.stringify(data) : undefined,\n  });\n  if (!response.ok) throw new Error(`API error: ${response.status} ${response.statusText}`);\n  return response.json();\n}\n\nasync function apiPut<T>(path: string, data?: any): Promise<T> {\n  const response = await fetch(`${API_URL}${path}`, {\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: data ? JSON.stringify(data) : undefined,\n  });\n  if (!response.ok) throw new Error(`API error: ${response.status} ${response.statusText}`);\n  return response.json();\n}\n\n// ============================================\n// MEMBER FUNCTIONS\n// ============================================\n\nexport const createDaoMember = async (data: DAOMemberInput): Promise<{ memberId: string }> => {\n    const result = await apiPost<{ success: boolean; memberId: string }>('/api/council', data);\n    return { memberId: result.memberId || 'new' };\n};\n\nexport const updateDaoMember = async (memberId: string, data: Partial<DAOMemberInput>): Promise<void> => {\n    await apiPut(`/api/council/${memberId}`, data);\n};\n\nexport const getDaoMember = async (memberId: string): Promise<DAOMember> => {\n    const result = await apiGet<{ success: boolean; data: DAOMember }>(`/api/council/${memberId}`);\n    return result.data;\n};\n\nexport const getDaoMembers = async (filters?: { roleType?: string; status?: string }): Promise<{\n    data: DAOMembersGrouped;\n    stats: DAOMembersStats;\n}> => {\n    let path = '/api/council';\n    const params: string[] = [];\n    if (filters?.roleType) params.push(`roleType=${filters.roleType}`);\n    if (filters?.status) params.push(`status=${filters.status}`);\n    if (params.length) path += '?' + params.join('&');\n\n    const result = await apiGet<{ success: boolean; data: DAOMembersGrouped; stats: DAOMembersStats }>(path);\n    return { data: result.data, stats: result.stats };\n};\n\nexport const getDaoMemberByUserId = async (userId?: string): Promise<DAOMember | null> => {\n    try {\n        const result = await apiGet<{ success: boolean; data: DAOMember | null }>(`/api/council?userId=${userId || ''}`);\n        return result.data;\n    } catch {\n        return null;\n    }\n};\n\n// ============================================\n// VESTING FUNCTIONS\n// ============================================\n\nexport const getVestingStatus = async (): Promise<VestingStatus | null> => {\n    try {\n        const result = await apiGet<{ success: boolean; data: VestingStatus | null }>('/api/tokens/vesting/status');\n        return result.data;\n    } catch {\n        return null;\n    }\n};\n\nexport const claimVestedTokens = async (amount?: number): Promise<{\n    claimedAmount: number;\n    newBalance: number;\n    remainingClaimable: number;\n}> => {\n    const result = await apiPost<{\n        success: boolean;\n        claimedAmount: number;\n        newBalance: number;\n        remainingClaimable: number;\n    }>('/api/tokens/vesting/claim', { amount });\n    return {\n        claimedAmount: result.claimedAmount,\n        newBalance: result.newBalance,\n        remainingClaimable: result.remainingClaimable,\n    };\n};\n\nexport const getClaimHistory = async (limit?: number): Promise<{ data: ClaimHistory[]; totalClaimed: number }> => {\n    const path = limit ? `/api/tokens/vesting/history?limit=${limit}` : '/api/tokens/vesting/history';\n    const result = await apiGet<{ success: boolean; data: ClaimHistory[]; totalClaimed: number }>(path);\n    return { data: result.data, totalClaimed: result.totalClaimed };\n};\n\nexport const createVestingSchedule = async (data: {\n    memberId: string;\n    userId: string;\n    totalTokens: number;\n    startDate: string;\n    endDate: string;\n    cliffDate?: string;\n}): Promise<{ scheduleId: string }> => {\n    const result = await apiPost<{ success: boolean; scheduleId: string }>('/api/tokens/vesting', data);\n    return { scheduleId: result.scheduleId };\n};\n\n// ============================================\n// PROPOSAL FUNCTIONS\n// ============================================\n\nexport const createProposal = async (data: {\n    title: string;\n    description: string;\n    durationDays: number;\n}): Promise<{ proposalId: string }> => {\n    const result = await apiPost<{ success: boolean; proposalId: string }>('/api/proposals', data);\n    return { proposalId: result.proposalId || 'new' };\n};\n\nexport const castVote = async (proposalId: string, voteType: VoteType): Promise<{ votingPower: number }> => {\n    const result = await apiPost<{ success: boolean; votingPower: number }>(`/api/proposals/${proposalId}/vote`, { voteType });\n    return { votingPower: result.votingPower || 0 };\n};\n\nexport const finalizeProposal = async (proposalId: string): Promise<{\n    status: ProposalStatus;\n    votesFor: number;\n    votesAgainst: number;\n    votesAbstain: number;\n}> => {\n    const result = await apiPost<{\n        success: boolean;\n        status: ProposalStatus;\n        votesFor: number;\n        votesAgainst: number;\n        votesAbstain: number;\n    }>(`/api/proposals/${proposalId}/finalize`, {});\n    return {\n        status: result.status,\n        votesFor: result.votesFor,\n        votesAgainst: result.votesAgainst,\n        votesAbstain: result.votesAbstain,\n    };\n};\n\nexport const cancelProposal = async (proposalId: string): Promise<void> => {\n    await apiPost(`/api/proposals/${proposalId}/cancel`, {});\n};\n\nexport const getProposals = async (filters?: { status?: ProposalStatus; limit?: number }): Promise<Proposal[]> => {\n    let path = '/api/proposals';\n    const params: string[] = [];\n    if (filters?.status) params.push(`status=${filters.status}`);\n    if (filters?.limit) params.push(`limit=${filters.limit}`);\n    if (params.length) path += '?' + params.join('&');\n\n    const result = await apiGet<Proposal[] | { success: boolean; data: Proposal[] }>(path);\n    return Array.isArray(result) ? result : result.data;\n};\n\nexport const getProposalVotes = async (proposalId: string): Promise<{ votes: Vote[]; myVote: Vote | null }> => {\n    try {\n        const result = await apiGet<{ success: boolean; data: Vote[]; myVote: Vote | null }>(`/api/proposals/${proposalId}/votes`);\n        return { votes: result.data || [], myVote: result.myVote || null };\n    } catch {\n        return { votes: [], myVote: null };\n    }\n};\n\nexport const hasVoted = async (proposalId: string): Promise<{ hasVoted: boolean; vote: Vote | null }> => {\n    try {\n        const result = await apiGet<{ success: boolean; hasVoted: boolean; vote: Vote | null }>(`/api/proposals/${proposalId}/has-voted`);\n        return { hasVoted: result.hasVoted, vote: result.vote };\n    } catch {\n        return { hasVoted: false, vote: null };\n    }\n};\n\nexport const getMyVotes = async (proposalIds?: string[]): Promise<Record<string, MyVote>> => {\n    try {\n        const path = proposalIds?.length ? `/api/proposals/my-votes?ids=${proposalIds.join(',')}` : '/api/proposals/my-votes';\n        const result = await apiGet<{ success: boolean; data: Record<string, My",
  "src/config/firebase.ts": "import { initializeApp } from 'firebase/app';\r\nimport { getAuth, sendSignInLinkToEmail, isSignInWithEmailLink, signInWithEmailLink, GoogleAuthProvider, signInWithPopup } from 'firebase/auth';\r\nimport { getFirestore, connectFirestoreEmulator } from 'firebase/firestore';\r\nimport { getFunctions, connectFunctionsEmulator, httpsCallable } from 'firebase/functions';\r\n\r\n// Firebase configuration\r\nconst firebaseConfig = {\r\n  apiKey: import.meta.env.VITE_FIREBASE_API_KEY || \"mock-api-key\",\r\n  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN || \"mock-project.firebaseapp.com\",\r\n  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID || \"mock-project\",\r\n  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET || \"mock-project.appspot.com\",\r\n  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID || \"123456789\",\r\n  appId: import.meta.env.VITE_FIREBASE_APP_ID || \"1:123456789:web:abc123\"\r\n};\r\n\r\n// Debug: Log Firebase configuration status\r\nconsole.log('üî• Firebase Config:', {\r\n  isConfigured: firebaseConfig.apiKey !== \"mock-api-key\",\r\n  apiKey: firebaseConfig.apiKey?.substring(0, 10) + '...',\r\n  projectId: firebaseConfig.projectId\r\n});\r\n\r\n// Initialize Firebase\r\nconst app = initializeApp(firebaseConfig);\r\nconst auth = getAuth(app);\r\nconst db = getFirestore(app);\r\nconst functions = getFunctions(app, 'us-central1');\r\n\r\n// Connect to emulators in development\r\nif (import.meta.env.DEV && import.meta.env.VITE_USE_EMULATORS === 'true') {\r\n  connectFirestoreEmulator(db, 'localhost', 8080);\r\n  connectFunctionsEmulator(functions, 'localhost', 5001);\r\n  console.log('üî• Connected to Firebase emulators');\r\n}\r\n\r\n/**\r\n * Send magic link to user's email\r\n */\r\nexport const sendMagicLink = async (email: string): Promise<void> => {\r\n  try {\r\n    // Include email in the callback URL for cross-browser/session compatibility\r\n    const actionCodeSettings = {\r\n      url: window.location.origin + '/?email=' + encodeURIComponent(email),\r\n      handleCodeInApp: true,\r\n    };\r\n\r\n    await sendSignInLinkToEmail(auth, email, actionCodeSettings);\r\n    // Save email to localStorage to complete sign-in (backup method)\r\n    window.localStorage.setItem('emailForSignIn', email);\r\n    console.log('Magic link sent to:', email);\r\n  } catch (error: any) {\r\n    console.error('Error sending magic link:', error);\r\n    throw new Error(error.message || 'Failed to send login link');\r\n  }\r\n};\r\n\r\n/**\r\n * Complete sign-in with email link\r\n */\r\nexport const completeMagicLinkSignIn = async (): Promise<{ email: string; uid: string }> => {\r\n  try {\r\n    if (!isSignInWithEmailLink(auth, window.location.href)) {\r\n      throw new Error('Invalid sign-in link');\r\n    }\r\n\r\n    // Try to get email from localStorage first\r\n    let email = window.localStorage.getItem('emailForSignIn');\r\n\r\n    // If not in localStorage, try to extract from URL params\r\n    if (!email) {\r\n      const urlParams = new URLSearchParams(window.location.search);\r\n      email = urlParams.get('email');\r\n    }\r\n\r\n    // If still no email, check if we can get it from the hash\r\n    if (!email && window.location.hash) {\r\n      const hashParams = new URLSearchParams(window.location.hash.substring(1));\r\n      email = hashParams.get('email');\r\n    }\r\n\r\n    if (!email) {\r\n      // Instead of prompting, throw a clear error\r\n      throw new Error('MISSING_EMAIL: Please open this link from the same browser where you requested it, or copy your email from the original request.');\r\n    }\r\n\r\n    console.log('Attempting to sign in with email:', email);\r\n    console.log('Current URL:', window.location.href);\r\n\r\n    const result = await signInWithEmailLink(auth, email, window.location.href);\r\n\r\n    // Clean up\r\n    window.localStorage.removeItem('emailForSignIn');\r\n    window.localStorage.removeItem('mockUser');\r\n\r\n    console.log('Sign-in successful:', result.user.email);\r\n\r\n    return {\r\n      email: result.user.email || email,\r\n      uid: result.user.uid\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error completing sign-in:', error);\r\n    console.error('Error code:', error.code);\r\n    console.error('Error message:', error.message);\r\n    throw new Error(error.message || 'Failed to sign in');\r\n  }\r\n};\r\n\r\n/**\r\n * Sign out current user\r\n */\r\nexport const signOut = async (): Promise<void> => {\r\n  try {\r\n    await auth.signOut();\r\n    window.localStorage.removeItem('emailForSignIn');\r\n    window.localStorage.removeItem('user');\r\n  } catch (error: any) {\r\n    console.error('Error signing out:', error);\r\n    throw new Error(error.message || 'Failed to sign out');\r\n  }\r\n};\r\n\r\n/**\r\n * Get current user\r\n */\r\nexport const getCurrentUser = () => {\r\n  return auth.currentUser;\r\n};\r\n\r\n/**\r\n * Check if Firebase is properly configured\r\n */\r\nexport const isFirebaseConfigured = (): boolean => {\r\n  return firebaseConfig.apiKey !== \"mock-api-key\";\r\n};\r\n\r\n/**\r\n * Sign in with Google (OAuth popup)\r\n */\r\nexport const signInWithGoogle = async (): Promise<{ email: string; uid: string; displayName?: string; photoURL?: string }> => {\r\n  try {\r\n    const provider = new GoogleAuthProvider();\r\n    const result = await signInWithPopup(auth, provider);\r\n\r\n    console.log('Google sign-in successful:', result.user.email);\r\n\r\n    return {\r\n      email: result.user.email || '',\r\n      uid: result.user.uid,\r\n      displayName: result.user.displayName || undefined,\r\n      photoURL: result.user.photoURL || undefined\r\n    };\r\n  } catch (error: any) {\r\n    console.error('Error signing in with Google:', error);\r\n    console.error('Error code:', error.code);\r\n    console.error('Error message:', error.message);\r\n\r\n    // Handle specific errors\r\n    if (error.code === 'auth/popup-closed-by-user') {\r\n      throw new Error('Sign-in popup was closed. Please try again.');\r\n    } else if (error.code === 'auth/popup-blocked') {\r\n      throw new Error('Popup was blocked by your browser. Please allow popups for this site.');\r\n    } else if (error.code === 'auth/cancelled-popup-request') {\r\n      throw new Error('Sign-in was cancelled.');\r\n    }\r\n\r\n    throw new Error(error.message || 'Failed to sign in with Google');\r\n  }\r\n};\r\n\r\nexport { auth, db, functions, httpsCallable };\r\n",
  "src/config/index.ts": "NOT_FOUND: ENOENT: no such file or directory, open 'C:\\Users\\User\\Documents\\GitHub\\DAOV1\\src\\config\\index.ts'",
  "vite.config.ts": "/// <reference types=\"vitest\" />\r\nimport path from 'path';\r\nimport { defineConfig, loadEnv } from 'vite';\r\n\r\nexport default defineConfig(({ mode }) => {\r\n    const env = loadEnv(mode, '.', '');\r\n    return {\r\n      define: {\r\n      // The API key is no longer exposed to the frontend.\r\n      },\r\n      server: {\r\n        proxy: {\r\n          '/api': {\r\n            target: 'http://localhost:5003',\r\n            changeOrigin: true,\r\n          },\r\n        },\r\n      },\r\n      resolve: {\r\n        alias: {\r\n          '@': path.resolve(__dirname, '.'),\r\n        }\r\n      },\r\n      build: {\r\n        // Reduce chunk size warning limit to 400KB\r\n        chunkSizeWarningLimit: 400,\r\n        rollupOptions: {\r\n          output: {\r\n            // Manual chunk splitting strategy\r\n            manualChunks: (id) => {\r\n              // Vendor chunks for large dependencies\r\n              if (id.includes('node_modules')) {\r\n                // Firebase in its own chunk\r\n                if (id.includes('firebase')) {\r\n                  return 'vendor-firebase';\r\n                }\r\n                // Google GenAI in its own chunk\r\n                if (id.includes('@google/genai')) {\r\n                  return 'vendor-genai';\r\n                }\r\n                // React and React-DOM together\r\n                if (id.includes('react') || id.includes('react-dom')) {\r\n                  return 'vendor-react';\r\n                }\r\n                // Other vendor libraries\r\n                return 'vendor-other';\r\n              }\r\n\r\n              // Template chunks - group by functionality\r\n              if (id.includes('/templates/')) {\r\n                if (id.includes('IdeaBubbles')) return 'template-bubbles';\r\n                if (id.includes('AdviserAgreements') || id.includes('AgreementNegotiation')) return 'template-agreements';\r\n                if (id.includes('GovernanceVoting')) return 'template-governance';\r\n                if (id.includes('TokenDistribution')) return 'template-tokens';\r\n                if (id.includes('IntegratedMarketplace')) return 'template-marketplace';\r\n                if (id.includes('DAOCreationWizard')) return 'template-wizard';\r\n                if (id.includes('Admin')) return 'template-admin';\r\n                return 'templates-other';\r\n              }\r\n\r\n              // Components chunk\r\n              if (id.includes('/components/') && !id.includes('/src/components/')) {\r\n                return 'components-shared';\r\n              }\r\n\r\n              // Services and utilities\r\n              if (id.includes('/service.ts') || id.includes('/services/')) {\r\n                return 'services';\r\n              }\r\n            },\r\n            // Optimize chunk file names\r\n            chunkFileNames: 'assets/[name]-[hash].js',\r\n            entryFileNames: 'assets/[name]-[hash].js',\r\n            assetFileNames: 'assets/[name]-[hash].[ext]',\r\n          }\r\n        },\r\n        // Enable minification and compression\r\n        minify: 'esbuild', // Use esbuild for faster minification (no extra deps needed)\r\n        // Drop console logs in production\r\n        esbuild: {\r\n          drop: mode === 'production' ? ['console', 'debugger'] : [],\r\n        },\r\n        // Source maps external in production for smaller bundle\r\n        sourcemap: mode === 'production' ? 'hidden' : true,\r\n      },\r\n      test: {\r\n        globals: true,\r\n        env: {\r\n          ADMIN_PASSWORD: 'test-admin-password',\r\n          GEMINI_API_KEY: 'test-key',\r\n          NODE_ENV: 'test',\r\n        },\r\n        environment: 'jsdom',\r\n        setupFiles: './vitest.setup.ts',\r\n        exclude: ['**/node_modules/**', 'e2e/**', 'tests/**', 'soda-treasury-service/**'],\r\n        environmentOptions: {\r\n          jsdom: {\r\n            resources: 'usable',\r\n          },\r\n        },\r\n        // Use the 'node' environment for backend tests\r\n        environmentMatchGlobs: [\r\n          ['backend/**', 'node'],\r\n        ],\r\n      },\r\n    };\r\n});\r\n",
  ".env": "NOT_FOUND: ENOENT: no such file or directory, open 'C:\\Users\\User\\Documents\\GitHub\\DAOV1\\.env'",
  ".env.local": "# DAO Frontend - Local Development\n# Empty VITE_API_URL means relative paths go through Vite proxy (/api -> localhost:5003)\nVITE_API_URL=\nVITE_BACKEND_URL=http://localhost:5003\nVITE_USE_EMULATORS=false\n",
  ".env.development": "NOT_FOUND: ENOENT: no such file or directory, open 'C:\\Users\\User\\Documents\\GitHub\\DAOV1\\.env.development'",
  "src/hooks/useConnectionStatus.ts": "/**\r\n * useConnectionStatus Hook\r\n *\r\n * Monitors network connection status:\r\n * - Monitors navigator.onLine\r\n * - Pings backend periodically\r\n * - Provides connection status and stability info\r\n */\r\n\r\nimport { useState, useEffect, useCallback, useRef } from 'react';\r\n\r\nexport interface ConnectionStatus {\r\n  isOnline: boolean;\r\n  isBackendReachable: boolean;\r\n  lastChecked: number | null;\r\n  latency: number | null; // ms\r\n  isStable: boolean; // true if no connection issues in last 5 minutes\r\n  consecutiveFailures: number;\r\n}\r\n\r\nexport interface UseConnectionStatusOptions {\r\n  pingInterval?: number; // ms between health checks (default: 30000 - 30s)\r\n  pingUrl?: string; // URL to ping for backend health\r\n  enabled?: boolean; // Enable/disable monitoring\r\n  onStatusChange?: (status: ConnectionStatus) => void;\r\n}\r\n\r\nconst API_URL = import.meta.env.VITE_API_URL || '';\r\nconst DEFAULT_PING_URL = `${API_URL}/api/health`;\r\nconst DEFAULT_PING_INTERVAL = 30000; // 30 seconds\r\nconst STABILITY_THRESHOLD = 5 * 60 * 1000; // 5 minutes\r\n\r\n/**\r\n * Hook to monitor connection status\r\n */\r\nexport function useConnectionStatus(options: UseConnectionStatusOptions = {}) {\r\n  const {\r\n    pingInterval = DEFAULT_PING_INTERVAL,\r\n    pingUrl = DEFAULT_PING_URL,\r\n    enabled = true,\r\n    onStatusChange,\r\n  } = options;\r\n\r\n  const [status, setStatus] = useState<ConnectionStatus>({\r\n    isOnline: navigator.onLine,\r\n    isBackendReachable: true, // Assume true initially\r\n    lastChecked: null,\r\n    latency: null,\r\n    isStable: true,\r\n    consecutiveFailures: 0,\r\n  });\r\n\r\n  const lastStableTime = useRef<number>(Date.now());\r\n  const abortControllerRef = useRef<AbortController | null>(null);\r\n\r\n  /**\r\n   * Ping the backend to check reachability\r\n   */\r\n  const pingBackend = useCallback(async (): Promise<{\r\n    reachable: boolean;\r\n    latency: number | null;\r\n  }> => {\r\n    if (!navigator.onLine) {\r\n      return { reachable: false, latency: null };\r\n    }\r\n\r\n    // Cancel previous request if still pending\r\n    if (abortControllerRef.current) {\r\n      abortControllerRef.current.abort();\r\n    }\r\n\r\n    abortControllerRef.current = new AbortController();\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      const response = await fetch(pingUrl, {\r\n        method: 'HEAD',\r\n        signal: abortControllerRef.current.signal,\r\n        cache: 'no-store',\r\n      });\r\n\r\n      const latency = Date.now() - startTime;\r\n\r\n      return {\r\n        reachable: response.ok,\r\n        latency: response.ok ? latency : null,\r\n      };\r\n    } catch (error: any) {\r\n      // Ignore abort errors\r\n      if (error.name === 'AbortError') {\r\n        return { reachable: false, latency: null };\r\n      }\r\n\r\n      return { reachable: false, latency: null };\r\n    }\r\n  }, [pingUrl]);\r\n\r\n  /**\r\n   * Update connection status\r\n   */\r\n  const updateStatus = useCallback(\r\n    async (isOnline: boolean) => {\r\n      if (!enabled) return;\r\n\r\n      let newStatus: ConnectionStatus;\r\n\r\n      if (!isOnline) {\r\n        // Offline - update immediately\r\n        newStatus = {\r\n          isOnline: false,\r\n          isBackendReachable: false,\r\n          lastChecked: Date.now(),\r\n          latency: null,\r\n          isStable: false,\r\n          consecutiveFailures: status.consecutiveFailures + 1,\r\n        };\r\n      } else {\r\n        // Online - check backend\r\n        const { reachable, latency } = await pingBackend();\r\n        const now = Date.now();\r\n\r\n        const consecutiveFailures = reachable ? 0 : status.consecutiveFailures + 1;\r\n\r\n        // Update stability: stable if no failures in threshold period\r\n        const isStable =\r\n          reachable && now - lastStableTime.current < STABILITY_THRESHOLD;\r\n\r\n        if (reachable) {\r\n          lastStableTime.current = now;\r\n        }\r\n\r\n        newStatus = {\r\n          isOnline: true,\r\n          isBackendReachable: reachable,\r\n          lastChecked: now,\r\n          latency,\r\n          isStable,\r\n          consecutiveFailures,\r\n        };\r\n      }\r\n\r\n      setStatus((prevStatus) => {\r\n        // Only update if status actually changed\r\n        const changed =\r\n          prevStatus.isOnline !== newStatus.isOnline ||\r\n          prevStatus.isBackendReachable !== newStatus.isBackendReachable ||\r\n          prevStatus.consecutiveFailures !== newStatus.consecutiveFailures;\r\n\r\n        if (changed && onStatusChange) {\r\n          onStatusChange(newStatus);\r\n        }\r\n\r\n        return newStatus;\r\n      });\r\n    },\r\n    [enabled, pingBackend, onStatusChange, status.consecutiveFailures]\r\n  );\r\n\r\n  /**\r\n   * Handle online/offline events\r\n   */\r\n  useEffect(() => {\r\n    if (!enabled) return;\r\n\r\n    const handleOnline = () => updateStatus(true);\r\n    const handleOffline = () => updateStatus(false);\r\n\r\n    window.addEventListener('online', handleOnline);\r\n    window.addEventListener('offline', handleOffline);\r\n\r\n    return () => {\r\n      window.removeEventListener('online', handleOnline);\r\n      window.removeEventListener('offline', handleOffline);\r\n    };\r\n  }, [enabled, updateStatus]);\r\n\r\n  /**\r\n   * Periodic backend health check\r\n   */\r\n  useEffect(() => {\r\n    if (!enabled || pingInterval <= 0) return;\r\n\r\n    // Initial check\r\n    updateStatus(navigator.onLine);\r\n\r\n    // Set up interval\r\n    const intervalId = setInterval(() => {\r\n      updateStatus(navigator.onLine);\r\n    }, pingInterval);\r\n\r\n    return () => {\r\n      clearInterval(intervalId);\r\n      // Cancel any pending requests\r\n      if (abortControllerRef.current) {\r\n        abortControllerRef.current.abort();\r\n      }\r\n    };\r\n  }, [enabled, pingInterval, updateStatus]);\r\n\r\n  /**\r\n   * Manual refresh\r\n   */\r\n  const refresh = useCallback(() => {\r\n    updateStatus(navigator.onLine);\r\n  }, [updateStatus]);\r\n\r\n  /**\r\n   * Check if safe to perform destructive actions\r\n   */\r\n  const isSafeForDestructiveAction = useCallback((): boolean => {\r\n    return status.isOnline && status.isBackendReachable && status.isStable;\r\n  }, [status]);\r\n\r\n  return {\r\n    ...status,\r\n    refresh,\r\n    isSafeForDestructiveAction,\r\n  };\r\n}\r\n",
  "src/council/service.ts": "NOT_FOUND: ENOENT: no such file or directory, open 'C:\\Users\\User\\Documents\\GitHub\\DAOV1\\src\\council\\service.ts'",
  "src/governance/service.ts": "import type { Proposal, ProposalStatusType } from '../../types';\r\nimport { retryWithBackoff, withTimeout } from '../utils/retryLogic';\r\nimport { circuitBreakerRegistry } from '../utils/circuitBreaker';\r\nimport { globalRequestCache } from '../utils/requestDeduplication';\r\nimport { toApiError } from '../utils/apiErrors';\r\n\r\n// Use environment variable or fallback to production API\r\nconst API_URL = import.meta.env.VITE_API_URL || '';\r\nconst PROPOSALS_ENDPOINT = `${API_URL}/api/proposals`;\r\nconst REQUEST_TIMEOUT = 30000; // 30 seconds\r\nconst CACHE_TTL = 60000; // 1 minute for GET requests\r\n\r\n// Circuit breaker for governance service\r\nconst governanceCircuit = circuitBreakerRegistry.getBreaker('governance', {\r\n  failureThreshold: 5,\r\n  timeout: 60000,\r\n  onStateChange: (state) => {\r\n    console.log(`Governance service circuit breaker: ${state}`);\r\n  },\r\n});\r\n\r\n/**\r\n * Enhanced fetch with retry, timeout, and circuit breaker\r\n */\r\nasync function resilientFetch<T>(\r\n  url: string,\r\n  options: RequestInit = {},\r\n  config: { skipCache?: boolean; cacheTTL?: number } = {}\r\n): Promise<T> {\r\n  const abortController = new AbortController();\r\n\r\n  try {\r\n    return await globalRequestCache.dedupe(\r\n      async () => {\r\n        return await governanceCircuit.execute(async () => {\r\n          return await retryWithBackoff(\r\n            async () => {\r\n              const timeoutPromise = withTimeout(\r\n                fetch(url, { ...options, signal: abortController.signal }),\r\n                REQUEST_TIMEOUT,\r\n                abortController.signal\r\n              );\r\n\r\n              const response = await timeoutPromise;\r\n\r\n              if (!response.ok) {\r\n                const error: any = new Error(`HTTP ${response.status}: ${response.statusText}`);\r\n                error.status = response.status;\r\n                error.response = response;\r\n                throw error;\r\n              }\r\n\r\n              return response.json() as Promise<T>;\r\n            },\r\n            {\r\n              maxRetries: 3,\r\n              signal: abortController.signal,\r\n            }\r\n          );\r\n        });\r\n      },\r\n      url,\r\n      { ...options, skipCache: config.skipCache, cacheTTL: config.cacheTTL }\r\n    );\r\n  } catch (error) {\r\n    abortController.abort();\r\n    throw toApiError(error);\r\n  }\r\n}\r\n\r\n/**\r\n * Interface for creating a new proposal\r\n */\r\nexport interface CreateProposalRequest {\r\n  title: string;\r\n  description: string;\r\n  type?: string;\r\n  status?: string;\r\n  creator: string;\r\n  startDate: string;\r\n  endDate: string;\r\n  yesVotes?: number;\r\n  noVotes?: number;\r\n  abstainVotes?: number;\r\n}\r\n\r\n/**\r\n * Interface for submitting a vote\r\n */\r\nexport interface SubmitVoteRequest {\r\n  voter: string;\r\n  vote: 'yes' | 'no' | 'abstain';\r\n  weight: number;\r\n  timestamp: string;\r\n}\r\n\r\n/**\r\n * Governance service object with all API methods and resilience features\r\n */\r\nexport const governanceService = {\r\n  /**\r\n   * Fetches all proposals with caching and retry logic\r\n   */\r\n  getAllProposals: async (options?: { skipCache?: boolean }): Promise<Proposal[]> => {\r\n    const data = await resilientFetch<any[]>(PROPOSALS_ENDPOINT, { method: 'GET' }, {\r\n      skipCache: options?.skipCache,\r\n      cacheTTL: CACHE_TTL,\r\n    });\r\n    return mapBackendProposalsToFrontend(data);\r\n  },\r\n\r\n  /**\r\n   * Fetches a single proposal by ID with caching and retry logic\r\n   */\r\n  getProposal: async (proposalId: string): Promise<Proposal> => {\r\n    const data = await resilientFetch<any>(`${PROPOSALS_ENDPOINT}/${proposalId}`, { method: 'GET' }, {\r\n      cacheTTL: CACHE_TTL,\r\n    });\r\n    return mapBackendProposalToFrontend(data);\r\n  },\r\n\r\n  /**\r\n   * Creates a new proposal with retry logic\r\n   */\r\n  createProposal: async (proposalData: CreateProposalRequest): Promise<Proposal> => {\r\n    const data = await resilientFetch<any>(\r\n      PROPOSALS_ENDPOINT,\r\n      {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(proposalData),\r\n      },\r\n      { skipCache: true }\r\n    );\r\n\r\n    // Invalidate proposals list cache\r\n    globalRequestCache.invalidate(/GET:.*\\/api\\/proposals/);\r\n\r\n    return mapBackendProposalToFrontend(data);\r\n  },\r\n\r\n  /**\r\n   * Submits a vote on a proposal with retry logic\r\n   */\r\n  vote: async (proposalId: string, voteData: SubmitVoteRequest): Promise<Proposal> => {\r\n    const data = await resilientFetch<any>(\r\n      `${PROPOSALS_ENDPOINT}/${proposalId}/vote`,\r\n      {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(voteData),\r\n      },\r\n      { skipCache: true }\r\n    );\r\n\r\n    // Invalidate related cache entries\r\n    globalRequestCache.invalidate(new RegExp(`GET:.*\\/api\\/proposals\\/${proposalId}`));\r\n    globalRequestCache.invalidate(/GET:.*\\/api\\/proposals$/);\r\n\r\n    return mapBackendProposalToFrontend(data);\r\n  },\r\n\r\n  /**\r\n   * Get circuit breaker status for monitoring\r\n   */\r\n  getCircuitStatus: () => governanceCircuit.getStats(),\r\n\r\n  /**\r\n   * Manually reset circuit breaker\r\n   */\r\n  resetCircuit: () => governanceCircuit.reset(),\r\n};\r\n\r\n/**\r\n * Maps backend proposal format to frontend Proposal type\r\n */\r\nfunction mapBackendProposalToFrontend(backendProposal: any): Proposal {\r\n  return {\r\n    id: backendProposal.id || backendProposal._id,\r\n    title: backendProposal.title,\r\n    description: backendProposal.description,\r\n    proposer: {\r\n      name: backendProposal.creator || 'Anonymous',\r\n      avatarUrl: backendProposal.creatorAvatar || 'https://api.dicebear.com/7.x/avataaars/svg?seed=default',\r\n    },\r\n    status: mapBackendStatusToFrontend(backendProposal.status),\r\n    votesFor: backendProposal.yesVotes || 0,\r\n    votesAgainst: backendProposal.noVotes || 0,\r\n    votesAbstain: backendProposal.abstainVotes || 0,\r\n    endDate: formatEndDate(backendProposal.endDate),\r\n  };\r\n}\r\n\r\n/**\r\n * Maps array of backend proposals to frontend format\r\n */\r\nfunction mapBackendProposalsToFrontend(backendProposals: any[]): Proposal[] {\r\n  return backendProposals.map(mapBackendProposalToFrontend);\r\n}\r\n\r\n/**\r\n * Maps backend status to frontend ProposalStatus enum\r\n */\r\nfunction mapBackendStatusToFrontend(status: string): ProposalStatusType {\r\n  const statusMap: Record<string, ProposalStatusType> = {\r\n    'active': 'Active',\r\n    'passed': 'Passed',\r\n    'failed': 'Failed',\r\n    'queued': 'Queued',\r\n  };\r\n  return statusMap[status.toLowerCase()] || 'Active';\r\n}\r\n\r\n/**\r\n * Formats end date for display\r\n */\r\nfunction formatEndDate(endDateString: string): string {\r\n  const endDate = new Date(endDateString);\r\n  const now = new Date();\r\n  const diffMs = endDate.getTime() - now.getTime();\r\n  const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\r\n\r\n  if (diffDays < 0) {\r\n    return 'Ended';\r\n  } else if (diffDays === 0) {\r\n    return 'Ends today';\r\n  } else if (diffDays === 1) {\r\n    return '1 day remaining';\r\n  } else if (diffDays < 7) {\r\n    return `${diffDays} days remaining`;\r\n  } else {\r\n    const weeks = Math.floor(diffDays / 7);\r\n    return weeks === 1 ? '1 week remaining' : `${weeks} weeks remaining`;\r\n  }\r\n}\r\n\r\n// Legacy exports for backward compatibility\r\nexport const getProposals = governanceService.getAllProposals;\r\nexport const submitVote = async (\r\n  proposalId: string,\r\n  voteType: 'for' | 'against' | 'abstain',\r\n  votingPower: number,\r\n  voterAddress: string\r\n): Promise<Proposal> => {\r\n  // Map old vote types to new format\r\n  const voteMap: Record<string, 'yes' | 'no' | 'abstain'> = {\r\n    'for': 'yes',\r\n    'against': 'no',\r\n    'abstain': 'abstain',\r\n  };\r\n\r\n  return governanceService.vote(proposalId, {\r\n    voter: voterAddress,\r\n    vote: voteMap[voteType],\r\n    weight: votingPower,\r\n    timestamp: new Date().toISOString(),\r\n  });\r\n};\r\n\r\n// Note: getUserVote functionality would need to be added to backend API\r\nexport const getUserVote = async (proposalId: string, voterAddress: string): Promise<{\r\n  proposalId: string;\r\n  voterAddress: string;\r\n  hasVoted: boolean;\r\n ",
  "src/marketplace/service.ts": "import { retryWithBackoff, withTimeout } from '../utils/retryLogic';\r\nimport { circuitBreakerRegistry } from '../utils/circuitBreaker';\r\nimport { globalRequestCache } from '../utils/requestDeduplication';\r\nimport { toApiError } from '../utils/apiErrors';\r\n\r\nconst API_URL = import.meta.env.VITE_API_URL || '';\r\nconst MARKETPLACE_API = `${API_URL}/api/marketplace`;\r\nconst REQUEST_TIMEOUT = 30000; // 30 seconds\r\nconst CACHE_TTL = 60000; // 1 minute for GET requests\r\n\r\n// Circuit breaker for marketplace service\r\nconst marketplaceCircuit = circuitBreakerRegistry.getBreaker('marketplace', {\r\n  failureThreshold: 5,\r\n  timeout: 60000,\r\n  onStateChange: (state) => {\r\n    console.log(`Marketplace service circuit breaker: ${state}`);\r\n  },\r\n});\r\n\r\n/**\r\n * Enhanced fetch with retry, timeout, and circuit breaker\r\n */\r\nasync function resilientFetch<T>(\r\n  url: string,\r\n  options: RequestInit = {},\r\n  config: { skipCache?: boolean; cacheTTL?: number } = {}\r\n): Promise<T> {\r\n  const abortController = new AbortController();\r\n\r\n  try {\r\n    return await globalRequestCache.dedupe(\r\n      async () => {\r\n        return await marketplaceCircuit.execute(async () => {\r\n          return await retryWithBackoff(\r\n            async () => {\r\n              const timeoutPromise = withTimeout(\r\n                fetch(url, { ...options, signal: abortController.signal }),\r\n                REQUEST_TIMEOUT,\r\n                abortController.signal\r\n              );\r\n\r\n              const response = await timeoutPromise;\r\n\r\n              if (!response.ok) {\r\n                const error: any = new Error(`HTTP ${response.status}: ${response.statusText}`);\r\n                error.status = response.status;\r\n                error.response = response;\r\n                throw error;\r\n              }\r\n\r\n              return response.json() as Promise<T>;\r\n            },\r\n            {\r\n              maxRetries: 3,\r\n              signal: abortController.signal,\r\n            }\r\n          );\r\n        });\r\n      },\r\n      url,\r\n      { ...options, skipCache: config.skipCache, cacheTTL: config.cacheTTL }\r\n    );\r\n  } catch (error) {\r\n    abortController.abort();\r\n    throw toApiError(error);\r\n  }\r\n}\r\n\r\n// Types\r\nexport interface MarketplaceItem {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  price: number;\r\n  category: 'Art' | 'Music' | 'Access' | 'Services' | 'Other';\r\n  imageUrl: string;\r\n  creator: {\r\n    name: string;\r\n    avatarUrl: string;\r\n    walletAddress: string;\r\n  };\r\n  status: 'active' | 'sold' | 'removed';\r\n  createdAt: string;\r\n  purchasedAt?: string;\r\n  purchasedBy?: string;\r\n}\r\n\r\nexport interface PurchaseResult {\r\n  success: boolean;\r\n  transaction: {\r\n    id: string;\r\n    itemId: string;\r\n    buyerWallet: string;\r\n    sellerWallet: string;\r\n    price: number;\r\n    timestamp: string;\r\n  };\r\n}\r\n\r\nexport interface UserBalance {\r\n  wallet: string;\r\n  balance: number;\r\n  lastUpdated: string;\r\n}\r\n\r\n/**\r\n * Service for managing Marketplace with full CRUD operations and resilience features\r\n */\r\nexport const marketplaceService = {\r\n  /**\r\n   * Fetches all marketplace items with caching and retry logic.\r\n   * @param filters Optional filters for category, status, etc.\r\n   */\r\n  getItems: async (filters?: {\r\n    category?: string;\r\n    status?: string;\r\n    skipCache?: boolean;\r\n  }): Promise<MarketplaceItem[]> => {\r\n    const queryParams = new URLSearchParams();\r\n    if (filters?.category) queryParams.append('category', filters.category);\r\n    if (filters?.status) queryParams.append('status', filters.status);\r\n\r\n    const url = `${MARKETPLACE_API}/items${queryParams.toString() ? `?${queryParams.toString()}` : ''}`;\r\n\r\n    return resilientFetch<MarketplaceItem[]>(url, { method: 'GET' }, {\r\n      skipCache: filters?.skipCache,\r\n      cacheTTL: CACHE_TTL,\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Alias for getItems() for backwards compatibility\r\n   */\r\n  getAllItems: async () => {\r\n    return marketplaceService.getItems();\r\n  },\r\n\r\n  /**\r\n   * Fetches a single marketplace item by ID.\r\n   * @param id The item ID\r\n   */\r\n  getItemById: async (id: string): Promise<MarketplaceItem> => {\r\n    return resilientFetch<MarketplaceItem>(\r\n      `${MARKETPLACE_API}/items/${id}`,\r\n      { method: 'GET' },\r\n      { cacheTTL: CACHE_TTL }\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Creates a new marketplace listing with retry logic.\r\n   * @param itemData The item data to create\r\n   */\r\n  createListing: async (itemData: Partial<MarketplaceItem>): Promise<MarketplaceItem> => {\r\n    const result = await resilientFetch<MarketplaceItem>(\r\n      `${MARKETPLACE_API}/items`,\r\n      {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(itemData),\r\n      },\r\n      { skipCache: true }\r\n    );\r\n\r\n    // Invalidate list cache\r\n    globalRequestCache.invalidate(/GET:.*\\/api\\/marketplace\\/items/);\r\n\r\n    return result;\r\n  },\r\n\r\n  /**\r\n   * Updates an existing marketplace item.\r\n   * @param id The item ID\r\n   * @param updates The fields to update\r\n   */\r\n  updateItem: async (\r\n    id: string,\r\n    updates: Partial<MarketplaceItem>\r\n  ): Promise<MarketplaceItem> => {\r\n    const result = await resilientFetch<MarketplaceItem>(\r\n      `${MARKETPLACE_API}/items/${id}`,\r\n      {\r\n        method: 'PATCH',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(updates),\r\n      },\r\n      { skipCache: true }\r\n    );\r\n\r\n    // Invalidate related cache entries\r\n    globalRequestCache.invalidate(/GET:.*\\/api\\/marketplace/);\r\n\r\n    return result;\r\n  },\r\n\r\n  /**\r\n   * Purchases a marketplace item with retry logic.\r\n   * @param itemId The ID of the item to purchase\r\n   * @param buyerWallet The buyer's wallet address\r\n   */\r\n  purchaseItem: async (\r\n    itemId: string,\r\n    buyerWallet: string\r\n  ): Promise<PurchaseResult> => {\r\n    const result = await resilientFetch<PurchaseResult>(\r\n      `${MARKETPLACE_API}/items/${itemId}/purchase`,\r\n      {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ buyerWallet }),\r\n      },\r\n      { skipCache: true }\r\n    );\r\n\r\n    // Invalidate related cache entries\r\n    globalRequestCache.invalidate(/GET:.*\\/api\\/marketplace/);\r\n\r\n    return result;\r\n  },\r\n\r\n  /**\r\n   * Gets the token balance for a wallet address.\r\n   * @param wallet The wallet address\r\n   */\r\n  getUserBalance: async (wallet: string): Promise<UserBalance> => {\r\n    return resilientFetch<UserBalance>(\r\n      `${MARKETPLACE_API}/balance/${wallet}`,\r\n      { method: 'GET' },\r\n      { cacheTTL: 30000 } // 30s cache for balance\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Gets purchase history for a wallet.\r\n   * @param wallet The wallet address\r\n   */\r\n  getPurchaseHistory: async (wallet: string): Promise<PurchaseResult['transaction'][]> => {\r\n    return resilientFetch<PurchaseResult['transaction'][]>(\r\n      `${MARKETPLACE_API}/history/${wallet}`,\r\n      { method: 'GET' },\r\n      { cacheTTL: CACHE_TTL }\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Gets purchases made by a user (alias for getPurchaseHistory)\r\n   * @param userId The user ID or wallet\r\n   */\r\n  getUserPurchases: async (userId: string): Promise<any[]> => {\r\n    return marketplaceService.getPurchaseHistory(userId);\r\n  },\r\n\r\n  /**\r\n   * Gets items listed by a specific wallet.\r\n   * @param wallet The wallet address\r\n   */\r\n  getUserListings: async (wallet: string): Promise<MarketplaceItem[]> => {\r\n    return resilientFetch<MarketplaceItem[]>(\r\n      `${MARKETPLACE_API}/listings/${wallet}`,\r\n      { method: 'GET' },\r\n      { cacheTTL: CACHE_TTL }\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Deletes a marketplace listing.\r\n   * @param id The item ID\r\n   */\r\n  deleteListing: async (id: string): Promise<void> => {\r\n    await resilientFetch<void>(\r\n      `${MARKETPLACE_API}/items/${id}`,\r\n      { method: 'DELETE' },\r\n      { skipCache: true }\r\n    );\r\n\r\n    // Invalidate related cache entries\r\n    globalRequestCache.invalidate(/GET:.*\\/api\\/marketplace/);\r\n  },\r\n\r\n  /**\r\n   * Get circuit breaker sta",
  "src/token-distribution/service.ts": "import { TokenDistributionGroup, VestingInfo, ClaimTokensResponse } from '../types';\r\nimport { retryWithBackoff, withTimeout } from '../utils/retryLogic';\r\nimport { circuitBreakerRegistry } from '../utils/circuitBreaker';\r\nimport { globalRequestCache } from '../utils/requestDeduplication';\r\nimport { toApiError } from '../utils/apiErrors';\r\n\r\nconst API_BASE_URL = import.meta.env.VITE_API_URL || '';\r\nconst API_URL = `${API_BASE_URL}/api/token-distribution`;\r\nconst REQUEST_TIMEOUT = 30000; // 30 seconds\r\nconst CACHE_TTL = 60000; // 1 minute for GET requests\r\n\r\n// Circuit breaker for token distribution service\r\nconst tokenDistributionCircuit = circuitBreakerRegistry.getBreaker('token-distribution', {\r\n  failureThreshold: 5,\r\n  timeout: 60000,\r\n  onStateChange: (state) => {\r\n    console.log(`Token distribution service circuit breaker: ${state}`);\r\n  },\r\n});\r\n\r\n/**\r\n * Enhanced fetch with retry, timeout, and circuit breaker\r\n */\r\nasync function resilientFetch<T>(\r\n  url: string,\r\n  options: RequestInit = {},\r\n  config: { skipCache?: boolean; cacheTTL?: number } = {}\r\n): Promise<T> {\r\n  const abortController = new AbortController();\r\n\r\n  try {\r\n    return await globalRequestCache.dedupe(\r\n      async () => {\r\n        return await tokenDistributionCircuit.execute(async () => {\r\n          return await retryWithBackoff(\r\n            async () => {\r\n              const timeoutPromise = withTimeout(\r\n                fetch(url, { ...options, signal: abortController.signal }),\r\n                REQUEST_TIMEOUT,\r\n                abortController.signal\r\n              );\r\n\r\n              const response = await timeoutPromise;\r\n\r\n              if (!response.ok) {\r\n                const error: any = new Error(`HTTP ${response.status}: ${response.statusText}`);\r\n                error.status = response.status;\r\n                error.response = response;\r\n                throw error;\r\n              }\r\n\r\n              return response.json() as Promise<T>;\r\n            },\r\n            {\r\n              maxRetries: 3,\r\n              signal: abortController.signal,\r\n            }\r\n          );\r\n        });\r\n      },\r\n      url,\r\n      { ...options, skipCache: config.skipCache, cacheTTL: config.cacheTTL }\r\n    );\r\n  } catch (error) {\r\n    abortController.abort();\r\n    throw toApiError(error);\r\n  }\r\n}\r\n\r\n/**\r\n * Fetches all token distribution groups with caching and retry logic.\r\n */\r\nexport const getTokenDistributionGroups = async (options?: { skipCache?: boolean }): Promise<TokenDistributionGroup[]> => {\r\n  return resilientFetch<TokenDistributionGroup[]>(API_URL, { method: 'GET' }, {\r\n    skipCache: options?.skipCache,\r\n    cacheTTL: CACHE_TTL,\r\n  });\r\n};\r\n\r\n/**\r\n * Fetches vesting information for a user in a specific group with retry logic.\r\n * @param groupId The ID of the group.\r\n * @param userId The ID of the user.\r\n */\r\nexport const getVestingInfo = async (groupId: string, userId: string): Promise<VestingInfo> => {\r\n  return resilientFetch<VestingInfo>(`${API_URL}/${groupId}/vested?userId=${userId}`, { method: 'GET' }, {\r\n    cacheTTL: CACHE_TTL,\r\n  });\r\n};\r\n\r\n/**\r\n * Claims a certain amount of tokens from a group with retry logic.\r\n * @param groupId The ID of the group to claim from.\r\n * @param userId The ID of the user claiming tokens.\r\n * @param amount The amount of tokens to claim.\r\n */\r\nexport const claimTokens = async (groupId: string, userId: string, amount: number): Promise<ClaimTokensResponse> => {\r\n  const result = await resilientFetch<ClaimTokensResponse>(\r\n    `${API_URL}/${groupId}/claim`,\r\n    {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ userId, amount }),\r\n    },\r\n    { skipCache: true }\r\n  );\r\n\r\n  // Invalidate related cache entries\r\n  globalRequestCache.invalidate(new RegExp(`GET:.*\\/api\\/token-distribution\\/${groupId}`));\r\n  globalRequestCache.invalidate(/GET:.*\\/api\\/token-distribution$/);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Token distribution service object with monitoring utilities\r\n */\r\nexport const tokenDistributionService = {\r\n  getTokenDistributionGroups,\r\n  getVestingInfo,\r\n  claimTokens,\r\n\r\n  /**\r\n   * Get circuit breaker status for monitoring\r\n   */\r\n  getCircuitStatus: () => tokenDistributionCircuit.getStats(),\r\n\r\n  /**\r\n   * Manually reset circuit breaker\r\n   */\r\n  resetCircuit: () => tokenDistributionCircuit.reset(),\r\n};\r\n",
  "src/hooks/dao/useDAOMembers.ts": "/**\r\n * useDAOMembers Hook\r\n * Get all DAO members (admin only)\r\n */\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { getDaoMembers, createDaoMember, updateDaoMember } from '../../dao/service';\r\nimport type { DAOMember, DAOMemberInput, DAOMembersGrouped, DAOMembersStats } from '../../dao/types';\r\n\r\ninterface UseDAOMembersFilters {\r\n  roleType?: string;\r\n  status?: string;\r\n}\r\n\r\ninterface UseDAOMembersResult {\r\n  members: DAOMembersGrouped;\r\n  stats: DAOMembersStats;\r\n  allMembers: DAOMember[];\r\n  loading: boolean;\r\n  error: string | null;\r\n  refetch: () => Promise<void>;\r\n  createMember: (data: DAOMemberInput) => Promise<string>;\r\n  updateMember: (memberId: string, data: Partial<DAOMemberInput>) => Promise<void>;\r\n}\r\n\r\nconst emptyGrouped: DAOMembersGrouped = {\r\n  founders: [],\r\n  advisors: [],\r\n  contributors: [],\r\n  firstborn: [],\r\n};\r\n\r\nconst emptyStats: DAOMembersStats = {\r\n  founders: { count: 0, tokens: 0, max: 7 },\r\n  advisors: { count: 0, tokens: 0 },\r\n  contributors: { count: 0, tokens: 0 },\r\n  firstborn: { count: 0, tokens: 0 },\r\n};\r\n\r\nexport const useDAOMembers = (filters?: UseDAOMembersFilters): UseDAOMembersResult => {\r\n  const [members, setMembers] = useState<DAOMembersGrouped>(emptyGrouped);\r\n  const [stats, setStats] = useState<DAOMembersStats>(emptyStats);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  const fetchMembers = useCallback(async () => {\r\n    setLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      const result = await getDaoMembers(filters);\r\n      setMembers(result.data);\r\n      setStats(result.stats);\r\n    } catch (err: any) {\r\n      console.error('Error fetching DAO members:', err);\r\n      setError(err.message || 'Failed to fetch members');\r\n      setMembers(emptyGrouped);\r\n      setStats(emptyStats);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [filters?.roleType, filters?.status]);\r\n\r\n  useEffect(() => {\r\n    fetchMembers();\r\n  }, [fetchMembers]);\r\n\r\n  const createMember = useCallback(async (data: DAOMemberInput): Promise<string> => {\r\n    const result = await createDaoMember(data);\r\n    await fetchMembers(); // Refetch after creation\r\n    return result.memberId;\r\n  }, [fetchMembers]);\r\n\r\n  const updateMember = useCallback(async (memberId: string, data: Partial<DAOMemberInput>): Promise<void> => {\r\n    await updateDaoMember(memberId, data);\r\n    await fetchMembers(); // Refetch after update\r\n  }, [fetchMembers]);\r\n\r\n  // Flatten all members into a single array\r\n  const allMembers = [\r\n    ...members.founders,\r\n    ...members.advisors,\r\n    ...members.contributors,\r\n    ...members.firstborn,\r\n  ];\r\n\r\n  return {\r\n    members,\r\n    stats,\r\n    allMembers,\r\n    loading,\r\n    error,\r\n    refetch: fetchMembers,\r\n    createMember,\r\n    updateMember,\r\n  };\r\n};\r\n\r\nexport default useDAOMembers;\r\n",
  "src/pages/Council.tsx": "NOT_FOUND: ENOENT: no such file or directory, open 'C:\\Users\\User\\Documents\\GitHub\\DAOV1\\src\\pages\\Council.tsx'",
  "src/pages/Dashboard.tsx": "import React, { useState, lazy, Suspense, useEffect, useCallback } from 'react';\r\nimport { PageLoadingSkeleton } from '../components/LoadingFallback';\r\nimport type { DAOData } from '../../types';\r\n\r\n// Lazy load heavy template components\r\nconst IdeaBubbles = lazy(() => import('../../templates/IdeaBubbles').then(m => ({ default: m.IdeaBubbles })));\r\nconst AdviserAgreements = lazy(() => import('../../templates/AdviserAgreements').then(m => ({ default: m.AdviserAgreements })));\r\nconst GovernanceVoting = lazy(() => import('../../templates/GovernanceVoting').then(m => ({ default: m.GovernanceVoting })));\r\nconst TokenDistribution = lazy(() => import('../../templates/TokenDistribution').then(m => ({ default: m.TokenDistribution })));\r\nconst IntegratedMarketplace = lazy(() => import('../../templates/IntegratedMarketplace').then(m => ({ default: m.IntegratedMarketplace })));\r\n\r\nconst API_URL = import.meta.env.VITE_API_URL || '';\r\n\r\ntype Tab = 'overview' | 'bubbles' | 'agreements' | 'governance' | 'tokens' | 'marketplace';\r\n\r\ninterface DashboardStats {\r\n  activeBubbles: number;\r\n  pendingVotes: number;\r\n  tokensClaimed: number;\r\n}\r\n\r\ninterface DashboardProps {\r\n  daoData: DAOData;\r\n  activeTab?: Tab;\r\n  onNavigate: (tab: Tab) => void;\r\n  onLogout: () => void;\r\n}\r\n\r\nexport const Dashboard: React.FC<DashboardProps> = ({\r\n  daoData,\r\n  activeTab = 'overview',\r\n  onNavigate,\r\n  onLogout\r\n}) => {\r\n  const [stats, setStats] = useState<DashboardStats>({\r\n    activeBubbles: 0,\r\n    pendingVotes: 0,\r\n    tokensClaimed: 0\r\n  });\r\n  const [isLoadingStats, setIsLoadingStats] = useState(true);\r\n  const [statsError, setStatsError] = useState<string | null>(null);\r\n\r\n  const fetchDashboardStats = useCallback(async () => {\r\n    setIsLoadingStats(true);\r\n    setStatsError(null);\r\n\r\n    try {\r\n      // Fetch all stats in parallel with better error handling\r\n      const [bubblesRes, proposalsRes, claimsRes] = await Promise.all([\r\n        fetch(`${API_URL}/api/bubbles`)\r\n          .then(r => r.ok ? r.json() : [])\r\n          .catch(() => []),\r\n        fetch(`${API_URL}/api/proposals`)\r\n          .then(r => r.ok ? r.json() : [])\r\n          .catch(() => []),\r\n        fetch(`${API_URL}/api/token-distribution/history`)\r\n          .then(r => r.ok ? r.json() : [])\r\n          .catch(() => [])\r\n      ]);\r\n\r\n      // Safely extract data - handle both array and object with data property\r\n      const bubblesData = Array.isArray(bubblesRes) ? bubblesRes : (bubblesRes?.data || []);\r\n      const proposalsData = Array.isArray(proposalsRes) ? proposalsRes : (proposalsRes?.data || []);\r\n      const claimsData = Array.isArray(claimsRes) ? claimsRes : (claimsRes?.data || []);\r\n\r\n      // Calculate stats with safe array operations\r\n      const activeBubbles = Array.isArray(bubblesData)\r\n        ? bubblesData.filter((b: any) => b?.status === 'active').length\r\n        : 0;\r\n\r\n      const pendingVotes = Array.isArray(proposalsData)\r\n        ? proposalsData.filter((p: any) => p?.status === 'Active' || p?.status === 'active').length\r\n        : 0;\r\n\r\n      const tokensClaimed = Array.isArray(claimsData)\r\n        ? claimsData.reduce((sum: number, claim: any) => sum + (claim?.amount || 0), 0)\r\n        : 0;\r\n\r\n      setStats({\r\n        activeBubbles,\r\n        pendingVotes,\r\n        tokensClaimed\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to fetch dashboard stats:', error);\r\n      setStatsError('Unable to load stats');\r\n      // Set default stats on error\r\n      setStats({\r\n        activeBubbles: 0,\r\n        pendingVotes: 0,\r\n        tokensClaimed: 0\r\n      });\r\n    } finally {\r\n      setIsLoadingStats(false);\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (activeTab === 'overview') {\r\n      fetchDashboardStats();\r\n    }\r\n  }, [activeTab, fetchDashboardStats]);\r\n\r\n  return (\r\n    <div className=\"min-h-screen w-full bg-gradient-to-br from-[#1c1642] to-[#0c0a1d]\">\r\n      {/* Header with DAO info */}\r\n      <header className=\"bg-slate-900/50 backdrop-blur-sm border-b border-purple-500/20 p-6\">\r\n        <div className=\"max-w-7xl mx-auto flex justify-between items-center\">\r\n          <div>\r\n            <h1 className=\"text-3xl font-bold text-white\">{daoData.daoDetails.name}</h1>\r\n            <p className=\"text-pink-100/90 mt-1\">\r\n              {daoData.daoDetails.description}\r\n            </p>\r\n          </div>\r\n          <button\r\n            onClick={onLogout}\r\n            className=\"px-4 py-2 bg-red-500/20 hover:bg-red-500/30 border border-red-400/50 rounded-lg text-red-200 transition-all\"\r\n          >\r\n            Logout\r\n          </button>\r\n        </div>\r\n      </header>\r\n\r\n      {/* Tab Navigation */}\r\n      <nav className=\"bg-slate-900/30 border-b border-purple-500/10\">\r\n        <div className=\"max-w-7xl mx-auto px-6\">\r\n          <div className=\"flex space-x-8\">\r\n            {[\r\n              { id: 'overview', label: 'Overview' },\r\n              { id: 'bubbles', label: 'Bubbles' },\r\n              { id: 'agreements', label: 'Agreements' },\r\n              { id: 'governance', label: 'Governance' },\r\n              { id: 'tokens', label: 'Tokens' },\r\n              { id: 'marketplace', label: 'Marketplace' }\r\n            ].map(tab => (\r\n              <button\r\n                key={tab.id}\r\n                onClick={() => onNavigate(tab.id as Tab)}\r\n                className={`py-4 px-2 border-b-2 transition-all ${\r\n                  activeTab === tab.id\r\n                    ? 'border-purple-400 text-purple-300'\r\n                    : 'border-transparent text-slate-400 hover:text-slate-200'\r\n                }`}\r\n              >\r\n                {tab.label}\r\n              </button>\r\n            ))}\r\n          </div>\r\n        </div>\r\n      </nav>\r\n\r\n      {/* Content Area */}\r\n      <main className=\"max-w-7xl mx-auto p-6\">\r\n        {activeTab === 'overview' && (\r\n          <div className=\"text-white\">\r\n            <div className=\"flex justify-between items-center mb-4\">\r\n              <h2 className=\"text-2xl font-bold\">Dashboard Overview</h2>\r\n              <button\r\n                onClick={fetchDashboardStats}\r\n                disabled={isLoadingStats}\r\n                className=\"px-3 py-1 text-sm bg-purple-500/20 hover:bg-purple-500/30 border border-purple-400/50 rounded-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed\"\r\n                aria-label=\"Refresh dashboard statistics\"\r\n              >\r\n                {isLoadingStats ? (\r\n                  <span className=\"flex items-center gap-2\">\r\n                    <svg className=\"animate-spin h-4 w-4\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\r\n                      <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\r\n                      <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\r\n                    </svg>\r\n                    Refreshing...\r\n                  </span>\r\n                ) : (\r\n                  <span className=\"flex items-center gap-2\">\r\n                    <svg className=\"h-4 w-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\r\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15\" />\r\n                    </svg>\r\n                    Refresh\r\n                  </span>\r\n                )}\r\n              </button>\r\n            </div>\r\n            <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\r\n              <div className=\"bg-purple-900/20 border border-purple-500/30 rounded-lg p-6 transition-all hover:border-purple-400/50\">\r\n                <h3 className=\"text-lg font-semibold mb-2\">Active Bubbles</h3>\r\n                {isLoadingStats ? (\r\n                  <div className=\"animate-pulse\">\r\n                    <div ",
  "src/pages/DashboardOverview.tsx": "import React, { useState, useCallback, useEffect } from 'react';\r\nimport { useOutletContext } from 'react-router-dom';\r\nimport type { DAOData } from '../../types';\r\nimport { AnimatedCount, AnimatedPercentage } from '../components/AnimatedNumber';\r\n\r\nconst API_URL = import.meta.env.VITE_API_URL || '';\r\n\r\ninterface DashboardStats {\r\n  activeBubbles: number;\r\n  pendingVotes: number;\r\n  tokensClaimed: number;\r\n}\r\n\r\ninterface OutletContext {\r\n  daoData: DAOData;\r\n}\r\n\r\nexport const DashboardOverview: React.FC = () => {\r\n  const { daoData } = useOutletContext<OutletContext>();\r\n  const [stats, setStats] = useState<DashboardStats>({\r\n    activeBubbles: 0,\r\n    pendingVotes: 0,\r\n    tokensClaimed: 0\r\n  });\r\n  const [isLoadingStats, setIsLoadingStats] = useState(true);\r\n  const [statsError, setStatsError] = useState<string | null>(null);\r\n\r\n  const fetchDashboardStats = useCallback(async () => {\r\n    setIsLoadingStats(true);\r\n    setStatsError(null);\r\n\r\n    try {\r\n      // Fetch all stats in parallel with better error handling\r\n      const [bubblesRes, proposalsRes, claimsRes] = await Promise.all([\r\n        fetch(`${API_URL}/api/bubbles`)\r\n          .then(r => r.ok ? r.json() : [])\r\n          .catch(() => []),\r\n        fetch(`${API_URL}/api/proposals`)\r\n          .then(r => r.ok ? r.json() : [])\r\n          .catch(() => []),\r\n        fetch(`${API_URL}/api/token-distribution/history`)\r\n          .then(r => r.ok ? r.json() : [])\r\n          .catch(() => [])\r\n      ]);\r\n\r\n      // Safely extract data - handle both array and object with data property\r\n      const bubblesData = Array.isArray(bubblesRes) ? bubblesRes : (bubblesRes?.data || []);\r\n      const proposalsData = Array.isArray(proposalsRes) ? proposalsRes : (proposalsRes?.data || []);\r\n      const claimsData = Array.isArray(claimsRes) ? claimsRes : (claimsRes?.data || []);\r\n\r\n      // Calculate stats with safe array operations\r\n      const activeBubbles = Array.isArray(bubblesData)\r\n        ? bubblesData.filter((b: any) => b?.status === 'active').length\r\n        : 0;\r\n\r\n      const pendingVotes = Array.isArray(proposalsData)\r\n        ? proposalsData.filter((p: any) => p?.status === 'Active' || p?.status === 'active').length\r\n        : 0;\r\n\r\n      const tokensClaimed = Array.isArray(claimsData)\r\n        ? claimsData.reduce((sum: number, claim: any) => sum + (claim?.amount || 0), 0)\r\n        : 0;\r\n\r\n      setStats({\r\n        activeBubbles,\r\n        pendingVotes,\r\n        tokensClaimed\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to fetch dashboard stats:', error);\r\n      setStatsError('Unable to load stats');\r\n      // Set default stats on error\r\n      setStats({\r\n        activeBubbles: 0,\r\n        pendingVotes: 0,\r\n        tokensClaimed: 0\r\n      });\r\n    } finally {\r\n      setIsLoadingStats(false);\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    fetchDashboardStats();\r\n  }, [fetchDashboardStats]);\r\n\r\n  // If no daoData passed, show loading or fetch it\r\n  if (!daoData) {\r\n    return (\r\n      <div className=\"text-white p-8\">\r\n        <p>Loading DAO data...</p>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"text-white\">\r\n      <div className=\"flex justify-between items-center mb-4\">\r\n        <h2 className=\"text-2xl font-bold\">Dashboard Overview</h2>\r\n        <button\r\n          onClick={fetchDashboardStats}\r\n          disabled={isLoadingStats}\r\n          className=\"px-3 py-1 text-sm bg-purple-500/20 hover:bg-purple-500/30 border border-purple-400/50 rounded-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed\"\r\n          aria-label=\"Refresh dashboard statistics\"\r\n        >\r\n          {isLoadingStats ? (\r\n            <span className=\"flex items-center gap-2\">\r\n              <svg className=\"animate-spin h-4 w-4\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\r\n                <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\r\n                <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\r\n              </svg>\r\n              Refreshing...\r\n            </span>\r\n          ) : (\r\n            <span className=\"flex items-center gap-2\">\r\n              <svg className=\"h-4 w-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15\" />\r\n              </svg>\r\n              Refresh\r\n            </span>\r\n          )}\r\n        </button>\r\n      </div>\r\n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\r\n        <div className=\"bg-purple-900/20 border border-purple-500/30 rounded-lg p-6 transition-all hover:border-purple-400/50\">\r\n          <h3 className=\"text-lg font-semibold mb-2\">Active Bubbles</h3>\r\n          {isLoadingStats ? (\r\n            <div className=\"animate-pulse\">\r\n              <div className=\"h-10 bg-purple-500/20 rounded w-20\"></div>\r\n            </div>\r\n          ) : statsError ? (\r\n            <p className=\"text-sm text-red-400\">{statsError}</p>\r\n          ) : (\r\n            <p className=\"text-3xl font-bold text-purple-300\">\r\n              <AnimatedCount value={stats.activeBubbles} />\r\n            </p>\r\n          )}\r\n        </div>\r\n        <div className=\"bg-pink-900/20 border border-pink-500/30 rounded-lg p-6 transition-all hover:border-pink-400/50\">\r\n          <h3 className=\"text-lg font-semibold mb-2\">Pending Votes</h3>\r\n          {isLoadingStats ? (\r\n            <div className=\"animate-pulse\">\r\n              <div className=\"h-10 bg-pink-500/20 rounded w-20\"></div>\r\n            </div>\r\n          ) : statsError ? (\r\n            <p className=\"text-sm text-red-400\">{statsError}</p>\r\n          ) : (\r\n            <p className=\"text-3xl font-bold text-pink-300\">\r\n              <AnimatedCount value={stats.pendingVotes} />\r\n            </p>\r\n          )}\r\n        </div>\r\n        <div className=\"bg-sky-900/20 border border-sky-500/30 rounded-lg p-6 transition-all hover:border-sky-400/50\">\r\n          <h3 className=\"text-lg font-semibold mb-2\">Tokens Claimed</h3>\r\n          {isLoadingStats ? (\r\n            <div className=\"animate-pulse\">\r\n              <div className=\"h-10 bg-sky-500/20 rounded w-32\"></div>\r\n            </div>\r\n          ) : statsError ? (\r\n            <p className=\"text-sm text-red-400\">{statsError}</p>\r\n          ) : (\r\n            <p className=\"text-3xl font-bold text-sky-300\">\r\n              <AnimatedCount value={stats.tokensClaimed} />\r\n            </p>\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      {/* DAO Details Section */}\r\n      <div className=\"mt-8 bg-slate-800/30 border border-slate-700/50 rounded-lg p-6\">\r\n        <h3 className=\"text-xl font-bold mb-4\">DAO Details</h3>\r\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4 text-sm\">\r\n          <div>\r\n            <p className=\"text-slate-300\">Total Token Supply</p>\r\n            <p className=\"text-white font-semibold\">{(daoData.totalSupply || 0).toLocaleString()} tokens</p>\r\n          </div>\r\n          <div>\r\n            <p className=\"text-slate-300\">Legal Origin</p>\r\n            <p className=\"text-white font-semibold\">{daoData.legal?.country || 'Not specified'}</p>\r\n          </div>\r\n          <div>\r\n            <p className=\"text-slate-300\">Description</p>\r\n            <p className=\"text-white\">{daoData.daoDetails.description}</p>\r\n          </div>\r\n          {daoData.daoDetails.logo && (\r\n            <div>\r\n              <p className=\"text-slate-300\">Logo</p>\r\n              <img src={daoData.daoDetails.logo} alt=\"DAO logo\" className=\"w-12 h-12 rounded-full border-2 border-purple-400 mt-1\"/>\r\n            </div>\r\n          )}\r\n        </div>\r\n\r\n        {/* Growth Distribution Section */}\r\n        {daoData.growthDistribution && (\r\n        <div clas",
  "src/layouts/DashboardLayout.tsx": "import React, { Suspense, lazy } from 'react';\r\nimport { Outlet, useNavigate } from 'react-router-dom';\r\nimport { PageLoadingSkeleton } from '../components/LoadingFallback';\r\n\r\nconst AIMentorWidget = lazy(() => import('../../components/AIMentorWidget').then(m => ({ default: m.AIMentorWidget })));\r\nconst AIMentorPanel = lazy(() => import('../../components/AIMentorPanel').then(m => ({ default: m.AIMentorPanel })));\r\nconst AdminAccessButton = lazy(() => import('../components/AdminAccessButton').then(m => ({ default: m.AdminAccessButton })));\r\n\r\nexport const DashboardLayout: React.FC = () => {\r\n  const navigate = useNavigate();\r\n  const [isPanelOpen, setIsPanelOpen] = React.useState(false);\r\n\r\n  return (\r\n    <>\r\n      {/* Child routes render here via Outlet */}\r\n      <Outlet />\r\n\r\n      {/* Global dashboard widgets */}\r\n      <Suspense fallback={null}>\r\n        <AIMentorWidget onClick={() => setIsPanelOpen(!isPanelOpen)} />\r\n        <AIMentorPanel\r\n          isOpen={isPanelOpen}\r\n          onClose={() => setIsPanelOpen(false)}\r\n          mentorHook={{ isPanelOpen, togglePanel: () => setIsPanelOpen(!isPanelOpen), setCurrentStep: () => {}, currentStep: 1 }}\r\n        />\r\n        <AdminAccessButton onClick={() => navigate('/admin')} />\r\n      </Suspense>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default DashboardLayout;\r\n",
  "index.tsx": "import React from 'react';\r\nimport ReactDOM from 'react-dom/client';\r\nimport './index.css';\r\nimport App from './App'; // The main application component\r\nimport { WalletContextProvider } from './src/contexts/WalletContextProvider';\r\n\r\n// Import admin setup utility (exposes window.setupAdmin)\r\nimport './src/utils/setupAdmin';\r\n\r\nconst rootElement = document.getElementById('root');\r\nif (!rootElement) {\r\n  throw new Error(\"Could not find root element to mount to\");\r\n}\r\n\r\nconst root = ReactDOM.createRoot(rootElement);\r\nroot.render(\r\n  <React.StrictMode>\r\n    <WalletContextProvider>\r\n      <App />\r\n    </WalletContextProvider>\r\n  </React.StrictMode>\r\n);"
}