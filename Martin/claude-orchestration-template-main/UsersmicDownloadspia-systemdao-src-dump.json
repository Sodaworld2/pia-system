{"backend/src/routes/council.ts":"import { Router } from 'express';\r\nimport db from '../database';\r\nimport logger from '../utils/logger';\r\n\r\nconst router = Router();\r\n\r\n/**\r\n * Council API Endpoint\r\n * Provides council member data grouped by role type with statistics\r\n */\r\n\r\n// Type definitions\r\ninterface CouncilMember {\r\n  id: number;\r\n  dao_id: number;\r\n  agreement_id: number | null;\r\n  name: string;\r\n  surname: string;\r\n  email: string;\r\n  phone: string | null;\r\n  wallet_address: string;\r\n  photo_url: string | null;\r\n  role_type: 'founder' | 'advisor' | 'contributor' | 'firstborn';\r\n  role_category: string | null;\r\n  custom_role_description: string | null;\r\n  token_allocation_total: number;\r\n  firestarter_period_months: number | null;\r\n  term_months: number | null;\r\n  status: 'draft' | 'pending_signature' | 'active' | 'completed' | 'cancelled';\r\n  created_at: string;\r\n  updated_at: string;\r\n  activated_at: string | null;\r\n  completed_at: string | null;\r\n  // Joined fields\r\n  agreement_title?: string;\r\n  agreement_status?: string;\r\n  milestones_completed?: number;\r\n  milestones_total?: number;\r\n}\r\n\r\ninterface RoleStats {\r\n  count: number;\r\n  max?: number;\r\n  tokens: number;\r\n}\r\n\r\ninterface CouncilStats {\r\n  founders: RoleStats;\r\n  advisors: RoleStats;\r\n  contributors: RoleStats;\r\n  firstborn: RoleStats;\r\n}\r\n\r\ninterface CouncilResponse {\r\n  success: boolean;\r\n  data: {\r\n    founders: CouncilMember[];\r\n    advisors: CouncilMember[];\r\n    contributors: CouncilMember[];\r\n    firstborn: CouncilMember[];\r\n  };\r\n  stats: CouncilStats;\r\n}\r\n\r\n// GET /api/council\r\n// Get all council members grouped by role\r\nrouter.get('/', async (req, res) => {\r\n  try {\r\n    const { dao_id, status, role_type } = req.query;\r\n\r\n    // Build query\r\n    let query = db('council_members')\r\n      .select(\r\n        'council_members.*',\r\n        'agreements.title as agreement_title',\r\n        'agreements.status as agreement_status'\r\n      )\r\n      .leftJoin('agreements', 'council_members.agreement_id', 'agreements.id');\r\n\r\n    // Apply filters\r\n    if (dao_id) {\r\n      query = query.where('council_members.dao_id', dao_id);\r\n    }\r\n\r\n    if (status) {\r\n      query = query.where('council_members.status', status);\r\n    }\r\n\r\n    if (role_type) {\r\n      query = query.where('council_members.role_type', role_type);\r\n    }\r\n\r\n    // Exclude cancelled members by default\r\n    query = query.whereNot('council_members.status', 'cancelled');\r\n\r\n    const members = await query.orderBy('council_members.created_at', 'desc');\r\n\r\n    // Get milestone counts for each member\r\n    const memberIds = members.map((m: CouncilMember) => m.id);\r\n\r\n    let milestoneCounts: any[] = [];\r\n    if (memberIds.length > 0) {\r\n      milestoneCounts = await db('milestones')\r\n        .whereIn('council_member_id', memberIds)\r\n        .select('council_member_id')\r\n        .count('* as total')\r\n        .sum(db.raw(\"CASE WHEN status = 'completed' THEN 1 ELSE 0 END as completed\"))\r\n        .groupBy('council_member_id');\r\n    }\r\n\r\n    // Create milestone loo","backend/src/routes/milestones.ts":"import { Router } from 'express';\r\nimport db from '../database';\r\nimport { sanitizeBody } from '../utils/sanitize';\r\nimport logger from '../utils/logger';\r\n\r\nconst router = Router();\r\n\r\n// Valid milestone statuses\r\nconst MILESTONE_STATUSES = ['pending', 'in_progress', 'completed'];\r\n\r\n// GET /api/milestones\r\n// List all milestones with optional filters\r\nrouter.get('/', async (req, res) => {\r\n    try {\r\n        const { agreement_id, council_member_id, status, dao_id } = req.query;\r\n\r\n        let query = db('milestones')\r\n            .select(\r\n                'milestones.*',\r\n                'council_members.name as member_name',\r\n                'council_members.surname as member_surname',\r\n                'agreements.title as agreement_title'\r\n            )\r\n            .leftJoin('council_members', 'milestones.council_member_id', 'council_members.id')\r\n            .leftJoin('agreements', 'milestones.agreement_id', 'agreements.id');\r\n\r\n        if (agreement_id) {\r\n            query = query.where('milestones.agreement_id', agreement_id);\r\n        }\r\n\r\n        if (council_member_id) {\r\n            query = query.where('milestones.council_member_id', council_member_id);\r\n        }\r\n\r\n        if (status) {\r\n            query = query.where('milestones.status', status);\r\n        }\r\n\r\n        if (dao_id) {\r\n            query = query.where('council_members.dao_id', dao_id);\r\n        }\r\n\r\n        const milestones = await query.orderBy('milestones.milestone_order', 'asc');\r\n\r\n        res.json({\r\n            success: true,\r\n            data: milestones,\r\n            count: milestones.length\r\n        });\r\n\r\n    } catch (error) {\r\n        logger.error('Error fetching milestones:', error);\r\n        res.status(500).json({\r\n            success: false,\r\n            error: 'Failed to fetch milestones',\r\n            code: 'INTERNAL_SERVER_ERROR'\r\n        });\r\n    }\r\n});\r\n\r\n// GET /api/milestones/:id\r\n// Get a single milestone by ID\r\nrouter.get('/:id', async (req, res) => {\r\n    const { id } = req.params;\r\n\r\n    try {\r\n        const milestone = await db('milestones')\r\n            .select(\r\n                'milestones.*',\r\n                'council_members.name as member_name',\r\n                'council_members.surname as member_surname',\r\n                'council_members.wallet_address',\r\n                'agreements.title as agreement_title',\r\n                'agreements.status as agreement_status'\r\n            )\r\n            .leftJoin('council_members', 'milestones.council_member_id', 'council_members.id')\r\n            .leftJoin('agreements', 'milestones.agreement_id', 'agreements.id')\r\n            .where('milestones.id', id)\r\n            .first();\r\n\r\n        if (!milestone) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                error: 'Milestone not found',\r\n                code: 'NOT_FOUND'\r\n            });\r\n        }\r\n\r\n        // Get related token release if exists\r\n        const tokenRelease = await db('token_release_schedu","backend/src/routes/signatures.ts":"import { Router } from 'express';\r\nimport db from '../database';\r\nimport signatureService from '../services/signatureService';\r\nimport signatureLinkService from '../services/signatureLinkService';\r\nimport { sanitizeBody } from '../utils/sanitize';\r\nimport { validate, validators } from '../middleware/validation';\r\n\r\nconst router = Router();\r\n\r\n/**\r\n * POST /api/signatures/sign\r\n * Sign an agreement (either as DAO or member)\r\n */\r\nrouter.post('/sign',\r\n  sanitizeBody(),\r\n  async (req, res) => {\r\n    try {\r\n      const { agreementId, signerType, signature, signerAddress, linkId } = req.body;\r\n\r\n      // Validate required fields\r\n      if (!agreementId || !signerType || !signature || !signerAddress) {\r\n        return res.status(400).json({\r\n          error: 'Missing required fields: agreementId, signerType, signature, signerAddress'\r\n        });\r\n      }\r\n\r\n      // Validate signer type\r\n      if (!['dao', 'member'].includes(signerType)) {\r\n        return res.status(400).json({ error: 'signerType must be \"dao\" or \"member\"' });\r\n      }\r\n\r\n      // Check if can sign\r\n      const canSignResult = await signatureService.canSign(agreementId, signerType);\r\n      if (!canSignResult.canSign) {\r\n        return res.status(400).json({ error: canSignResult.reason });\r\n      }\r\n\r\n      // For member signing via link, validate the link\r\n      if (signerType === 'member' && linkId) {\r\n        const linkValidation = await signatureLinkService.validateLink(linkId);\r\n        if (!linkValidation.valid) {\r\n          return res.status(400).json({ error: linkValidation.error });\r\n        }\r\n        if (linkValidation.agreementId !== agreementId) {\r\n          return res.status(400).json({ error: 'Link does not match agreement' });\r\n        }\r\n      }\r\n\r\n      // Create the message that was signed\r\n      const timestamp = Date.now();\r\n      const message = signatureService.createSigningMessage(agreementId, signerType, timestamp);\r\n\r\n      // Verify the signature (Solana by default)\r\n      const isValid = signatureService.verifySignature(message, signature, signerAddress, 'solana');\r\n\r\n      // For now, we'll store even if verification fails but mark as unverified\r\n      // In production, you might want to reject invalid signatures\r\n      if (!isValid) {\r\n        console.warn(`Signature verification failed for ${signerAddress} on agreement ${agreementId}`);\r\n        // Continue but log warning - in dev, signature verification may fail due to message mismatch\r\n      }\r\n\r\n      // Store the signature\r\n      await signatureService.storeSignature(agreementId, signerType, signature, signerAddress, message);\r\n\r\n      // If this was a member signing via link, mark the link as used\r\n      if (signerType === 'member' && linkId) {\r\n        await signatureLinkService.markUsed(linkId);\r\n      }\r\n\r\n      // Check if both signatures are now present and activate if so\r\n      const status = await signatureService.getSignatureStatus(agreementId);\r\n      let activated = false;\r\n      if (stat","backend/src/routes/contracts.ts":"import { Router } from 'express';\r\nimport db from '../database';\r\nimport logger from '../utils/logger';\r\nimport { GoogleGenerativeAI } from '@google/generative-ai';\r\nimport { sanitizeBody } from '../utils/sanitize';\r\n\r\nconst router = Router();\r\nconst genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');\r\n\r\n// GET /api/contracts/:contractId\r\n// Get generated contract details\r\nrouter.get('/:contractId', async (req, res) => {\r\n    const { contractId } = req.params;\r\n\r\n    try {\r\n        const contract = await db('generated_contracts')\r\n            .where('id', contractId)\r\n            .first();\r\n\r\n        if (!contract) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                error: 'Contract not found',\r\n                code: 'CONTRACT_NOT_FOUND'\r\n            });\r\n        }\r\n\r\n        res.json({\r\n            success: true,\r\n            data: {\r\n                contract_id: contract.id,\r\n                status: contract.status,\r\n                contract_text: contract.contract_text,\r\n                contract_version: contract.contract_version,\r\n                agreement_type: contract.agreement_type,\r\n                legal_framework: contract.legal_framework,\r\n                generated_at: contract.generated_at,\r\n                generated_by: contract.generated_by,\r\n                approved_by: contract.approved_by,\r\n                approved_at: contract.approved_at,\r\n                error_message: contract.error_message\r\n            }\r\n        });\r\n\r\n    } catch (error) {\r\n        logger.error('Error fetching contract:', error);\r\n        res.status(500).json({\r\n            success: false,\r\n            error: 'Failed to fetch contract',\r\n            code: 'INTERNAL_SERVER_ERROR'\r\n        });\r\n    }\r\n});\r\n\r\n// POST /api/contracts/:contractId/regenerate\r\n// Regenerate contract with new version\r\nrouter.post('/:contractId/regenerate',\r\n    sanitizeBody(),\r\n    async (req, res) => {\r\n        const { contractId } = req.params;\r\n        const { custom_terms } = req.body;\r\n\r\n        try {\r\n            // Get existing contract\r\n            const existingContract = await db('generated_contracts')\r\n                .where('id', contractId)\r\n                .first();\r\n\r\n            if (!existingContract) {\r\n                return res.status(404).json({\r\n                    success: false,\r\n                    error: 'Contract not found',\r\n                    code: 'CONTRACT_NOT_FOUND'\r\n                });\r\n            }\r\n\r\n            // Get agreement and council member details\r\n            const agreement = await db('agreements')\r\n                .where('id', existingContract.agreement_id)\r\n                .first();\r\n\r\n            const councilMember = await db('council_members')\r\n                .where('id', existingContract.council_member_id)\r\n                .first();\r\n\r\n            if (!agreement || !councilMember) {\r\n                return res.status(404).json({\r\n                    success: false,\r\n       ","backend/src/routes/tokens.ts":"import express from 'express';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport db from '../database';\r\nimport { incrementBalance, decrementBalance } from '../utils/optimistic-locking';\r\n\r\nconst router = express.Router();\r\n\r\n// Get user balance\r\nrouter.get('/balance/:userId', async (req, res) => {\r\n  try {\r\n    const { userId } = req.params;\r\n\r\n    const user = await db('user_balances').where({ user_id: userId }).first();\r\n\r\n    if (!user) {\r\n      // Create new user with default balance\r\n      await db('user_balances').insert({\r\n        user_id: userId,\r\n        soda_balance: 0,\r\n        bubble_score: 0\r\n      });\r\n      res.json({ userId, sodaBalance: 0, bubbleScore: 0 });\r\n    } else {\r\n      res.json({\r\n        userId: user.user_id,\r\n        sodaBalance: user.soda_balance,\r\n        bubbleScore: user.bubble_score\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error('Error fetching balance:', error);\r\n    res.status(500).json({ error: 'Failed to fetch balance' });\r\n  }\r\n});\r\n\r\n// Transfer tokens between users\r\nrouter.post('/transfer', async (req, res) => {\r\n  try {\r\n    const { fromUser, toUser, amount, memo } = req.body;\r\n\r\n    if (!fromUser || !toUser || !amount || amount <= 0) {\r\n      return res.status(400).json({ error: 'Invalid transfer request' });\r\n    }\r\n\r\n    // Check sender balance\r\n    const sender = await db('user_balances').where({ user_id: fromUser }).first();\r\n\r\n    if (!sender || sender.soda_balance < amount) {\r\n      return res.status(400).json({ error: 'Insufficient balance' });\r\n    }\r\n\r\n    // Deduct from sender with optimistic locking\r\n    const senderResult = await decrementBalance(fromUser, 'soda_balance', amount);\r\n\r\n    // Add to receiver with optimistic locking\r\n    const receiver = await db('user_balances').where({ user_id: toUser }).first();\r\n    let receiverResult;\r\n    if (receiver) {\r\n      receiverResult = await incrementBalance(toUser, 'soda_balance', amount);\r\n    } else {\r\n      // Create new receiver account\r\n      await db('user_balances').insert({\r\n        user_id: toUser,\r\n        soda_balance: amount,\r\n        bubble_score: 0,\r\n        version: 1\r\n      });\r\n      receiverResult = { newBalance: amount };\r\n    }\r\n\r\n    // Record transaction\r\n    const txId = uuidv4();\r\n    await db('token_transactions').insert({\r\n      id: txId,\r\n      from_user: fromUser,\r\n      to_user: toUser,\r\n      amount,\r\n      transaction_type: 'transfer',\r\n      memo: memo || 'Transfer',\r\n      status: 'completed'\r\n    });\r\n\r\n    res.json({\r\n      success: true,\r\n      transactionId: txId,\r\n      senderNewBalance: senderResult.newBalance,\r\n      receiverNewBalance: receiverResult.newBalance\r\n    });\r\n  } catch (error) {\r\n    console.error('Error transferring tokens:', error);\r\n    res.status(500).json({ error: 'Failed to transfer tokens' });\r\n  }\r\n});\r\n\r\n// Reward tokens to a user\r\nrouter.post('/reward', async (req, res) => {\r\n  try {\r\n    const { userId, amount, reason, referenceId } = req.body;\r\n\r\n    if (!userId || !amount |","backend/src/routes/marketplace.ts":"import express from 'express';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport db from '../database';\r\nimport { incrementBalance, decrementBalance } from '../utils/optimistic-locking';\r\n\r\nconst router = express.Router();\r\n\r\n// Get all marketplace items\r\nrouter.get('/items', async (req, res) => {\r\n  try {\r\n    const { type, status } = req.query;\r\n\r\n    let query = db('marketplace_items');\r\n\r\n    // Filter by type if provided\r\n    if (type && type !== 'All') {\r\n      query = query.where('type', type);\r\n    }\r\n\r\n    // Filter by status (default to 'active')\r\n    if (status) {\r\n      query = query.where('status', status);\r\n    } else {\r\n      query = query.where('status', 'active');\r\n    }\r\n\r\n    const items = await query.orderBy('created_at', 'desc');\r\n\r\n    // Format items to match frontend MarketplaceItem interface\r\n    const formattedItems = items.map(item => ({\r\n      id: item.id,\r\n      name: item.name,\r\n      type: item.type,\r\n      price: item.price,\r\n      imageUrl: item.image_url,\r\n      description: item.description,\r\n      category: item.category,\r\n      creator: {\r\n        name: item.creator_name,\r\n        avatarUrl: item.creator_avatar_url\r\n      },\r\n      edition: item.edition_total ? {\r\n        current: item.edition_current || item.sold_count,\r\n        total: item.edition_total\r\n      } : undefined,\r\n      status: item.status,\r\n      quantity: item.quantity,\r\n      soldCount: item.sold_count\r\n    }));\r\n\r\n    res.json(formattedItems);\r\n  } catch (error) {\r\n    console.error('Error fetching marketplace items:', error);\r\n    res.status(500).json({ error: 'Failed to fetch marketplace items' });\r\n  }\r\n});\r\n\r\n// Get single marketplace item by ID\r\nrouter.get('/items/:id', async (req, res) => {\r\n  try {\r\n    const { id } = req.params;\r\n    const item = await db('marketplace_items').where({ id }).first();\r\n\r\n    if (!item) {\r\n      return res.status(404).json({ error: 'Item not found' });\r\n    }\r\n\r\n    // Format item to match frontend MarketplaceItem interface\r\n    const formattedItem = {\r\n      id: item.id,\r\n      name: item.name,\r\n      type: item.type,\r\n      price: item.price,\r\n      imageUrl: item.image_url,\r\n      description: item.description,\r\n      category: item.category,\r\n      creator: {\r\n        name: item.creator_name,\r\n        avatarUrl: item.creator_avatar_url\r\n      },\r\n      edition: item.edition_total ? {\r\n        current: item.edition_current || item.sold_count,\r\n        total: item.edition_total\r\n      } : undefined,\r\n      status: item.status,\r\n      quantity: item.quantity,\r\n      soldCount: item.sold_count\r\n    };\r\n\r\n    res.json(formattedItem);\r\n  } catch (error) {\r\n    console.error('Error fetching marketplace item:', error);\r\n    res.status(500).json({ error: 'Failed to fetch marketplace item' });\r\n  }\r\n});\r\n\r\n// Create a new marketplace item\r\nrouter.post('/items', async (req, res) => {\r\n  try {\r\n    const {\r\n      name,\r\n      type,\r\n      price,\r\n      description,\r\n      imageUrl,\r\n      sellerId,\r\n      category,\r\n","backend/src/routes/treasury.ts":"import { Router } from 'express';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport db from '../database';\r\nimport { TreasuryTransaction } from '../types';\r\nimport { validate, validators } from '../middleware/validation';\r\nimport { sanitizeBody } from '../utils/sanitize';\r\n\r\nconst router = Router();\r\n\r\n// Helper function to calculate treasury balance\r\nasync function calculateTreasuryBalance(): Promise<number> {\r\n    // Starting balance (could be moved to a config table later)\r\n    const INITIAL_BALANCE = 1000000;\r\n\r\n    // Get all executed withdrawals (recipient is NOT treasury)\r\n    const executedWithdrawals = await db('treasury_transactions')\r\n        .where('status', 'Executed')\r\n        .whereNot('recipient', 'treasury')\r\n        .whereNot('recipient', 'treasury_deposit')\r\n        .sum('amount as total')\r\n        .first();\r\n\r\n    // Get all deposits (recipient is treasury or treasury_deposit, status is Executed/Completed)\r\n    const deposits = await db('treasury_transactions')\r\n        .where(function() {\r\n            this.where('recipient', 'treasury')\r\n                .orWhere('recipient', 'treasury_deposit');\r\n        })\r\n        .where(function() {\r\n            this.where('status', 'Executed')\r\n                .orWhere('status', 'Completed');\r\n        })\r\n        .sum('amount as total')\r\n        .first();\r\n\r\n    const totalWithdrawals = executedWithdrawals?.total || 0;\r\n    const totalDeposits = deposits?.total || 0;\r\n    const currentBalance = INITIAL_BALANCE + totalDeposits - totalWithdrawals;\r\n\r\n    return currentBalance;\r\n}\r\n\r\n// GET /api/treasury/vitals\r\nrouter.get('/vitals', async (req, res) => {\r\n    try {\r\n        const policy = await db('treasury_policies').first();\r\n        const signers = await db('treasury_signers').select();\r\n\r\n        // Calculate actual balance from transaction history\r\n        const balance = await calculateTreasuryBalance();\r\n\r\n        res.json({\r\n            balance,\r\n            policy: {\r\n                requiredSignatures: policy.required_signatures,\r\n                totalSigners: signers.length,\r\n            },\r\n            signers,\r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching treasury vitals:', error);\r\n        res.status(500).json({ error: 'Failed to fetch treasury vitals' });\r\n    }\r\n});\r\n\r\n// GET /api/treasury/transactions\r\nrouter.get('/transactions', async (req, res) => {\r\n    try {\r\n        const transactions = await db('treasury_transactions').select('*').orderBy('created_at', 'desc');\r\n\r\n        const transactionsWithApprovals = await Promise.all(transactions.map(async (tx) => {\r\n            const approvals = await db('treasury_approvals')\r\n                .where('transaction_id', tx.id)\r\n                .select('signer_address');\r\n            return {\r\n                ...tx,\r\n                approvals: approvals.map(a => a.signer_address),\r\n            };\r\n        }));\r\n\r\n        res.json(transactionsWithApprovals);\r\n    } catch (error) {\r\n        console.error('Err","backend/src/routes/founder-agreements.ts":"import { Router } from 'express';\r\nimport db from '../database';\r\nimport { validate, validators } from '../middleware/validation';\r\nimport { sanitizeBody } from '../utils/sanitize';\r\nimport logger from '../utils/logger';\r\nimport { GoogleGenerativeAI } from '@google/generative-ai';\r\n\r\nconst router = Router();\r\nconst genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');\r\n\r\n// GET /api/agreements/founder\r\n// Get all founder agreements\r\nrouter.get('/', async (req, res) => {\r\n    try {\r\n        const { dao_id } = req.query;\r\n\r\n        let query = db('council_members')\r\n            .where('role_type', 'founder')\r\n            .select(\r\n                'council_members.*',\r\n                'agreements.id as agreement_id',\r\n                'agreements.title as agreement_title',\r\n                'agreements.status as agreement_status',\r\n                'agreements.created_at as agreement_created_at'\r\n            )\r\n            .leftJoin('agreements', 'council_members.agreement_id', 'agreements.id');\r\n\r\n        if (dao_id) {\r\n            query = query.where('council_members.dao_id', dao_id);\r\n        }\r\n\r\n        const founders = await query.orderBy('council_members.created_at', 'desc');\r\n\r\n        res.json({\r\n            success: true,\r\n            data: founders,\r\n            count: founders.length\r\n        });\r\n\r\n    } catch (error) {\r\n        logger.error('Error fetching founder agreements:', error);\r\n        res.status(500).json({\r\n            success: false,\r\n            error: 'Failed to fetch founder agreements',\r\n            code: 'INTERNAL_SERVER_ERROR'\r\n        });\r\n    }\r\n});\r\n\r\n// GET /api/agreements/founder/:id\r\n// Get a specific founder agreement by ID\r\nrouter.get('/:id', async (req, res) => {\r\n    const { id } = req.params;\r\n\r\n    try {\r\n        const councilMember = await db('council_members')\r\n            .where('council_members.id', id)\r\n            .where('role_type', 'founder')\r\n            .select(\r\n                'council_members.*',\r\n                'agreements.id as agreement_id',\r\n                'agreements.title as agreement_title',\r\n                'agreements.description as agreement_description',\r\n                'agreements.status as agreement_status',\r\n                'agreements.details as agreement_details',\r\n                'agreements.created_at as agreement_created_at'\r\n            )\r\n            .leftJoin('agreements', 'council_members.agreement_id', 'agreements.id')\r\n            .first();\r\n\r\n        if (!councilMember) {\r\n            return res.status(404).json({\r\n                success: false,\r\n                error: 'Founder agreement not found',\r\n                code: 'NOT_FOUND'\r\n            });\r\n        }\r\n\r\n        // Get milestones\r\n        const milestones = await db('milestones')\r\n            .where('council_member_id', id)\r\n            .orderBy('milestone_order');\r\n\r\n        // Get generated contracts\r\n        const contracts = await db('generated_contracts')\r\n            .where('council_member","backend/src/database.ts":"import knex from 'knex';\r\n\r\nconst db = knex({\r\n  client: 'sqlite3',\r\n  connection: {\r\n    filename: './mentor_chats.db',\r\n  },\r\n  useNullAsDefault: true,\r\n});\r\n\r\nexport async function initializeDatabase() {\r\n  const hasMessagesTable = await db.schema.hasTable('messages');\r\n  if (!hasMessagesTable) {\r\n    await db.schema.createTable('messages', (table) => {\r\n      table.increments('id').primary();\r\n      table.string('sessionId').notNullable();\r\n      table.string('sender').notNullable();\r\n      table.text('text').notNullable();\r\n      table.timestamp('timestamp').defaultTo(db.fn.now());\r\n    });\r\n    console.log('Database initialized and \"messages\" table created.');\r\n  }\r\n\r\n  const hasDaosTable = await db.schema.hasTable('daos');\r\n  if (!hasDaosTable) {\r\n    await db.schema.createTable('daos', (table) => {\r\n      table.increments('id').primary();\r\n      // daoDetails\r\n      table.string('daoName').notNullable();\r\n      table.text('description').notNullable();\r\n      table.text('logo'); // Storing logo as base64 string\r\n      // totalSupply\r\n      table.bigInteger('totalSupply').notNullable().defaultTo(10000000000);\r\n      // growthDistribution\r\n      table.integer('founders_growth').notNullable().defaultTo(0);\r\n      table.integer('operational').notNullable().defaultTo(0);\r\n      table.integer('scale_community').notNullable().defaultTo(0);\r\n      // tokenomics (Council Distribution)\r\n      table.integer('founders').notNullable();\r\n      table.integer('advisors').notNullable();\r\n      table.integer('foundation').notNullable();\r\n      table.integer('firstBorns').notNullable();\r\n      // legal\r\n      table.string('country').notNullable();\r\n      table.text('generatedContract'); // Optional now\r\n\r\n      table.timestamp('createdAt').defaultTo(db.fn.now());\r\n    });\r\n    console.log('Database initialized and \"daos\" table created.');\r\n  } else {\r\n    // Add new columns if they don't exist (for existing databases)\r\n    const hasDescription = await db.schema.hasColumn('daos', 'description');\r\n    if (!hasDescription) {\r\n      await db.schema.alterTable('daos', (table) => {\r\n        table.text('description');\r\n        table.bigInteger('totalSupply').defaultTo(10000000000);\r\n        table.integer('founders_growth').defaultTo(0);\r\n        table.integer('operational').defaultTo(0);\r\n        table.integer('scale_community').defaultTo(0);\r\n      });\r\n      console.log('Added new columns to existing \"daos\" table.');\r\n    }\r\n  }\r\n\r\n  const hasUserProfilesTable = await db.schema.hasTable('user_profiles');\r\n  if (!hasUserProfilesTable) {\r\n    await db.schema.createTable('user_profiles', (table) => {\r\n      table.increments('id').primary();\r\n      table.string('sessionId').notNullable().unique();\r\n      table.string('learning_style');\r\n      table.timestamp('createdAt').defaultTo(db.fn.now());\r\n    });\r\n    console.log('Database initialized and \"user_profiles\" table created.');\r\n  }\r\n\r\n  const hasUserDaosTable = await db.schema.hasTable('user_daos');\r\n  if (!hasUser"}